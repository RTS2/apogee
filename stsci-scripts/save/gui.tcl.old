
# 
# This file contains the the scripts which create the Apogee camera GUI. The procedures
# use the C++ API via a wrapper generated by SWIG.
#
#


#
# Create the status window. This window is used to display informative messages
# during initialization.
#

toplevel .status -width 500 -height 100
wm title .status "Apogee Camera Control"
wm geometry .status +20+30
label .status.msg -bg LightBlue -fg Black -text Initialising -width 50 -font "Helvetica 30 bold"
pack .status.msg



#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : showstatus
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This routine displays text messages in the status window
#
#  Arguments  :
#
#               msg	-	message text
 
proc showstatus { msg } {
 
#
#  Globals    :		n/a
#  
  .status.msg configure -text "$msg"
  update
}


#
# Define the global environment, everything lives under /opt/apogee
# Change TKAPOGEE to move the code somewhere else
#
set TKAPOGEE /opt/apogee

#
# Define the path to the shared libraries.
# These libraries are used to add facilities to the default tcl/tk
# wish shell. 
#
set libs /opt/apogee/lib

#
# Load the tcl interface to FITS (Flexible image transport system) disk files
# FITS is the standard disk file format for Astronomical data
#

showstatus "Loading FitsTcl"
load $libs/libfitsTcl.so

# Prepare for Guide Star Catalog access
package ifneeded gsc 3.1       [load $libs/libgsc.so]

# Prepare for Digital sky survey access
package ifneeded dss 3.1       [load $libs/libdss.so]

# Prepare for Oracle (target ephemeris prediction)
package ifneeded oracle 2.1    [load $libs/liboracle.so]

# Prepare for generic astrometry
package ifneeded xtcs 3.1      [load $libs/libxtcs.so]

# Prepare for Graphics widget package
package ifneeded BLT 2.4       [load $libs/libBLT24.so]

# Prepare for Ccd image buffering package
package ifneeded ccd 1.0       [load $libs/libccd.so]

# Load packages provided by dynamically loadable libraries
showstatus "Loading Digital Sky survey access"
package require dss
showstatus "Loading GSC catalog access"
package require gsc
showstatus "Loading Oracle"
package require oracle
showstatus "Loading graphics package"
package require BLT
namespace import blt::graph
showstatus "Loading CCD package"
package require ccd
lappend auto_path $libs/BWidget-1.2.1
package require BWidget






#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : getDSS
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure provides access to the Digital Sky Survey (100x compressed)
#  dataset. These can be purchased from "The Astronomical Society of the Pacific"
#  The cdroms provide 1arcsec resolution coverage of the entire sky. 
#  The location of the DSS files is specified by the configuration in
#  /opt/apogee/scripts/dss.env
#
#  Arguments  :
#
#               name	-	Image file name
#               ra	-	RA in the form hh:mm:ss.ss
#               dec	-	DEC in the form +ddd:mm:ss.ss
#               xsize	-	X dimension in arcmin
#               ysize	-	Y dimension in arcmin
 
proc getDSS {name ra dec xsize ysize } {
 
#
#  Globals    :		n/a
#  
   set fout [open /tmp/dsscmd w]
   puts $fout "$name [split $ra :] [split $dec :] $xsize $ysize"
   close $fout
   dss -i /tmp/dsscmd
   set f [glob $name*.fits]
   checkDisplay
   exec xpaset -p ds9 file $f
}




#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : checkDisplay
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure checks if the image display tool DS9 is up and running.
#  If not we start a copy. The xpans server is used to communicate with DS9
#  it should always be running, as a copy is started by the /opt/apogee/scripts/setup.env
#
#  Arguments  :
#
 
proc checkDisplay { } {
 
#
#  Globals    :		n/a
#  
   set x ""
   catch {set x [exec xpaget ds9]}
   if { $x == "" } {
      exec /opt/apogee/bin/ds9 &
   }
}




#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : getGSC
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This proceduure provides access to the Compressed version of the Hubble
#  Guide Star Catalog. This catalog contains the same set of objects, but 
#  occupies only ~300Mb of disk space, rather than 2 full cdroms.
#
#  The obtained set of positions are overlaid on the current image displayed
#  in the DS9 image display tool. For other purposes, simply use the 
#  cmdGFind call to return the list of objects for further processing.
#
#  Arguments  :
#
#               ra	-	RA in the form hh:mm:ss.ss
#               dec	-	DEC in the form +ddd:mm:ss.ss
#               xsize	-	X dimension in arcmin
#               ysize	-	Y dimension in arcmin
 
proc getGSC { ra dec xsize ysize } {
 
#
#  Globals    :		n/a
#  
   if { $xsize < 0 } {
      set results [exec cat testgsc.dat]
   } else {
      set results [cmdGFind $ra $dec $xsize $ysize]
   }
   set byline [lrange [split $results "\n"] 1 end]
   exec xpaset -p ds9 regions deleteall                                                
   foreach l $byline {
      set lra  [join [lrange $l 1 3] :]
      set ldec [join [lrange $l 4 6] :]
      exec xpaset -p ds9 regions circle $lra $ldec 5.
   }
}




#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : locateObjs
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  Test routine, will eventually be part of automatic image coordinate
#  system calibration
#
#  Arguments  :
#
 
proc locateObjs { } {
 
#
#  Globals    :		n/a
#  
   set fin [open test.cat r]
   exec xpaset -p ds9 regions coordformat xy
   exec xpaset -p ds9 regions deleteall                                                
   set i 7
   while { $i > 0 } {gets $fin rec ;  incr i -1}
   while { [gets $fin rec] > -1 } {
      exec xpaset -p ds9 regions circle [lindex $rec 4] [lindex $rec 5] 5.
   }
}




#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : getRegion
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure will eventaully be part of automatic coordinate determination
#
#  Arguments  :
#
 
proc getRegion { } {
 
#
#  Globals    :		n/a
#  
   set res [exec xpaget  ds9 regions]
   set i [lsearch $res "image\;box"]
   if { $i < 0 } {
      exec  xpaset -p ds9 regions deleteall  
      tk_dialog
   }
   set lx [lindex $res [expr $i+1]]
   set ly [lindex $res [expr $i+2]]
   set nx [lindex $res [expr $i+3]]
   set ny [lindex $res [expr $i+4]]
#  test command for sextractor
# /opt/apogee/bin/sextractor -DETECT_MINAREA 10 -DETECT_THRESH 30 test207vo.fits        
}




#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : autoIdentify
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  Experimental - This procedure attempts to autocorrelate image coordinate
#  lists between GSC and an  sextractor run
#
#
#  Arguments  :
#
#               imax	-	Maximum number of candidates (optional, default is 20)
#               type	-	Calibration type (flat,dark,sky,zero) (optional, default is raw)
#               aspp	-	Threshold (optional, default is 1.7)
 
proc autoIdentify { {imax 20} {type raw} {aspp 1.7} } {
 
#
#  Globals    :
#  
#               X	-	X data for temperature plot
#               Y	-	Y data for temperature plot
#               F	-	 
global X Y F
    exec sort -r +2 test.cat > stest.dat
    if { $type == "raw" } {
     set fin [open stest.dat r]
     set i 1
     while { $i < $imax } {
        gets $fin rec
        if { [string range $rec 0 0] != "#" } {   
          set X($i) [lindex $rec 4]
          set Y($i) [lindex $rec 5]
          set F($i) [lindex $rec 2]
          incr i 1
        }
     }
     close $fin
    } 
    if { $type == "gsc" } {
     set fin [open testgsc.dat r]
     set i 1
     set DEC 50
     while { $i < $imax } {
        gets $fin rec
        set dec [expr ([lindex $rec 4]*3600+[lindex $rec 5]*60+[lindex $rec 6])  / $aspp]
        set ra [expr ([lindex $rec 1]*3600+[lindex $rec 2]*60+[lindex $rec 3]) *15. / $aspp]
        set ra [expr $ra*cos($DEC/180.*3.14159)]
        set X($i) $ra
        set Y($i) $dec
        set F($i) [lindex $rec 7]
        incr i 1
     }
     close $fin
    } 
    set i 1
    while { $i < $imax } {
       set mind 9999999999.
       set maxd 0.
       set j 1
       while { $j < $imax  } {
         if { $i != $j } {
           set d [expr sqrt( ($X($i)-$X($j))*($X($i)-$X($j)) + ($Y($i)-$Y($j))*($Y($i)-$Y($j)) )]
           if { $d > $maxd } {set maxd $d}
           if { $d < $mind && $d > 50.} {
              set mind $d
              set minj($i) $j
           }
         }
         incr j 1
       }
       set M($i) [expr $maxd / $mind]
       puts stdout "$i $mind $minj($i)"
       incr i 1
    }
}






#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : choosedir
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure prompts the user to specify a directory using a 
#  flexible GUI interface.
#
#  Arguments  :
#
#               type	-	Calibration type (flat,dark,sky,zero)
#               name	-	Image file name
 
proc choosedir { type name} {
 
#
#  Globals    :
#  
#               CALS	-	Calibration run parmaeters
#               CATALOGS	-	Catalog configurations
#               SCOPE	-	Telescope parameters, gui setup
global CALS CATALOGS SCOPE
   if { $type == "data" } {
     set cfg [tk_chooseDirectory -initialdir $SCOPE(datadir)/$name]
     set SCOPE(datadir) $cfg
     .main.seldir configure -text "$cfg"
   } else {
     set cfg [tk_chooseDirectory -initialdir $CALS(home)/$name]
   }
   if { [file exists $cfg] == 0 } {
      exec mkdir -p $cfg
   }
   switch $type {
       calibrations {set CALS($name,dir) $cfg }
       catalogs     {set CATALOGS($name,dir) $cfg }
   }
}

#
#
#  Set defaults for the directories used to store calibration 
#  library frames
#
set CALS(home) $env(HOME)/calibrations
set CALS(zero,dir) $CALS(home)/zero
set CALS(dark,dir) $CALS(home)/dark
set CALS(flat,dir) $CALS(home)/flat
set CALS(skyflat,dir) $CALS(home)/skyflat
set SCOPE(datadir) $env(HOME)




#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : inspectapi
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure inspects the set of wrapper commands generated by SWIG.
#  These commands will be of the form Object_somename_set/get, and the
#  instance variable wrappers will be of the form -m_somename.
#  This predictable nomenclature is exploited to parse the set of 
#  all available commands, and seek out all those associated with 
#  the named C++ object type.
#
#  This ensures that when facilities are added to the C++ code, only
#  minimal rewrite (if any) will be needed in the tcl code.
#
#  Arguments  :
#
#               object	-	Name of wrapped C++ object
 
proc inspectapi { object } {
 
#
#  Globals    :
#  
#               CCAPIR	-	C++ readable instance variables
#               CCAPIW	-	C++ writable instance variables
global CCAPIR CCAPIW
  set all [info commands]
  foreach i $all { 
     set s [split $i _]
     if { [lindex $s 0] == $object } {
        if { [lindex $s end] == "get" } {
           set name [join [lrange $s 1 [expr [llength $s]-2]] _]
           set CCAPIR($name) cget
        }
        if { [lindex $s end] == "set" } {
           set name [join [lrange $s 1 [expr [llength $s]-2]] _]
           set CCAPIW($name) configure
        }
        if { [lindex $s 1] == "read" } {
           set name [join [lrange $s 1 end] _]
           set CCAPIR($name) method
        }
        if { [lindex $s 1] == "write" } {
           set name [join [lrange $s 1 end] _]
           set CCAPIW($name) method
        }
     }
  }
}






#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : printcamdata
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure loop thru all the items in CAMSTATUS and 
#  prints the current values, primarily for interactive debugging use.
#
#  Arguments  :
#
#               id	-	Camera id (for multi-camera use) (optional, default is 0)
 
proc printcamdata { {id 0} } {
 
#
#  Globals    :
#  
#               CAMERAS	-	Camera id's
#               CAMSTATUS	-	Current values of camera variables
global CAMERAS CAMSTATUS
    foreach i [lsort [array names CAMSTATUS]] { 
        puts stdout "$i = $CAMSTATUS($i)"
    }
}





#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : refreshcamdata
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure interrogates the current value of all instance variables
#  exported from the C++ api. Values are stored into the global array
#  CAMSTATUS for easy acces from the tcl code
#
#  Arguments  :
#
#               id	-	Camera id (for multi-camera use) (optional, default is 0)
 
proc refreshcamdata { {id 0} } {
 
#
#  Globals    :
#  
#               CAMSTATUS	-	Current values of camera variables
#               CCAPIR	-	C++ readable instance variables
#               CCAPI	-	Generic C++ object names
#               CAMERAS	-	Camera id's
#               CONFIG	-	GUI configuration
global CAMSTATUS CCAPIR CCAPI CAMERAS CONFIG
    set camera $CAMERAS($id)
    foreach i [lsort [array names CCAPIR]] { 
       if { $CCAPIR($i) == "method" } {
          set CAMSTATUS([string range $i 5 end]) [$camera $i]
          set name [string range $i 5 end]
          if { [info exists CCAPI($name)] } {
             set CONFIG($CCAPI($name)) $CAMSTATUS($name)
          }
       }
       if { $CCAPIR($i) == "cget" } {
          set name [string range $i 2 end]
          set CAMSTATUS($name) [$camera cget -$i]
          if { [info exists CCAPI($name)] } {
             set CONFIG($CCAPI($name)) $CAMSTATUS($name)
          }
       }
    }
}





#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : get_temp
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure retrieves the current ccd temperature, it is included so that
#  future versions can transparently support other makes of camera.
#
#  Arguments  :
#
#               id	-	Camera id (for multi-camera use) (optional, default is 0)
 
proc get_temp { {id 0} } {
 
#
#  Globals    :
#  
#               CAMERAS	-	Camera id's
global CAMERAS
   set t [$CAMERAS($id) read_Temperature]
   return $t
}





#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : setpoint
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure controls the operation of the cooling circuit. 
#  The cooler can be swithed off, ramped to ambient, or ramped to 
#  a required target temperature.
#
#  Arguments  :
#
#               op	-	Operation specifier
#               t	-	Temperature (degrees c) (optional, default is 10.0)
#               id	-	Camera id (for multi-camera use) (optional, default is 0)
 
proc setpoint { op {t 10.0} {id 0} } {
 
#
#  Globals    :
#  
#               CCD_TMP	-	 
#               SETPOINTS	-	Cooler setpoints
#               CAMERAS	-	Camera id's
global CCD_TMP SETPOINTS CAMERAS
    set op [string toupper $op]
    set camera $CAMERAS($id)
    switch $op {
       SET { $camera write_CoolerMode 1 
             $camera write_CoolerSetPoint $t 
           }
       AMB { $camera write_CoolerMode 2 
           }
       OFF { $camera write_CoolerMode 0
           }
    }
    if { $op == "SET" } {
       set SETPOINTS $t
    } else {
       set SETPOINTS 99
    }
}
   

#
#  Define globals for temperature control

set TEMPS ""
set STATUS(tempgraph) 1







#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : monitortemp
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure monitors the ccd temperature, and periodically calls 
#  plottemp to update the graphical display. The temperature as plotted is
#  based on an average of the last 10 values, this is done because the 
#  least significant bit of the temperature ADC represents ~0.5degrees
#  and averaging produces a more representative display.
#
#  Arguments  :
#
#               id	-	Camera id (for multi-camera use) (optional, default is 0)
 
proc monitortemp { {id 0} } {
 
#
#  Globals    :
#  
#               TEMPS	-	Raw temperatures
#               AVGTEMPS	-	Average temps for plotting
#               STATUS	-	Exposure status
global TEMPS AVGTEMPS STATUS
  if { $STATUS(tempgraph) }  {
   set t [lindex [get_temp $id] 0]
   if { $TEMPS == "" } {
       set TEMPS "$t $t $t $t $t $t $t $t $t $t"
   } else {
       set TEMPS [lrange "$t $TEMPS" 0 9]
   }
   set i 0
   set temp 0
   while { $i < 10 } {set temp [expr $temp+[lindex $TEMPS $i]] ; incr i 1}
   set AVGTEMPS [expr $temp/10.0]
   plottemp
   after 5000 monitortemp
  }
}

 



#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : plottemp
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure updates the graphical display of temperature.
#  It uses the  BLT graph widget to do all the hard work.
#
#  Arguments  :
#
 
proc plottemp { } {
 
#
#  Globals    :
#  
#               ydata	-	temp plot array - temp
#               ysetp	-	temp plot array - setpoint
#               TEMPWIDGET	-	BLT temperature graph widget name
#               AVGTEMPS	-	Average temps for plotting
#               SETPOINTS	-	Cooler setpoints
global ydata ysetp TEMPWIDGET AVGTEMPS SETPOINTS
   set ydata "[lrange [split $ydata] 1 59] $AVGTEMPS"
   if { $SETPOINTS == 99 }  {
      set ysetp "[lrange [split $ysetp] 1 59] $AVGTEMPS"
   } else {
      set ysetp "[lrange [split $ysetp] 1 59] $SETPOINTS"
   }
   $TEMPWIDGET element configure Temp -symbol none -ydata $ydata
   $TEMPWIDGET element configure SetPoint -color red -symbol none -ydata $ysetp
   setminmax
}





#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : setminmax
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure resets the display parameters for the temperature
#  graphic in an attempt to autoscale it to the recent range.
#
#  Arguments  :
#
 
proc setminmax { } {
 
#
#  Globals    :
#  
#               ydata	-	temp plot array - temp
#               ysetp	-	temp plot array - setpoint
#               TEMPWIDGET	-	BLT temperature graph widget name
global ydata ysetp TEMPWIDGET
  set min  9999999
  set max -9999999 
  foreach i $ydata { 
     if { $i < $min } { set min $i } 
     if { $i > $max } { set max $i } 
  }
  foreach i $ysetp { 
     if { $i < $min } { set min $i } 
     if { $i > $max } { set max $i } 
  }
  set r [expr ($max-$min)/5.+1.]
  $TEMPWIDGET yaxis configure -min [expr $min-$r] -max [expr $max+$r]
}






set PI 3.14159265359




#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : tlabel
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure takes an input time in radians and converts it to hh:mm:ss form
#
#  Arguments  :
#
#               atime	-	Time in radians
 
proc tlabel { atime } {
 
#
#  Globals    :
#  
#               PI	-	 
global PI
    if { $atime < 0 } {
       set asign "-"
       set atime [expr -$atime]
    } else {
       set asign ""
    }
    set atime [expr $atime/$PI*12.0]
    set ahrs [expr int($atime)]
    set amins [expr int(60*($atime-$ahrs))]
    set asecs [expr int(($atime-$ahrs-$amins/60.0)*3600.0)]
    set out ""
    if { $ahrs < 10 } {
      set ahrs "0$ahrs"
    }
    if { $amins < 10 } {
      set amins "0$amins"
    }
    if { $asecs < 10 } {
      set asecs "0$asecs"
    }
    return "$asign$ahrs:$amins:$asecs"
}
                                                                                





#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : showconfig
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure toggles visibility of the properties window.
#
#  Arguments  :
#
 
proc showconfig { } {
 
#
#  Globals    :
#  
  if { [winfo ismapped .p] } {
     wm withdraw .p
  } else {
     wm deiconify .p
  }
}

set STATUS(busy) 0




#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : snapshot
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure is a minimal interface to take an exposure
#
#  Arguments  :
#
#               name	-	Image file name
#               exp	-	Exposure time in seconds
#               bcorr	-	Bias correction (1=yes) (optional, default is 0)
#               shutter	-	Shutter open(1), closed(0) (optional, default is 1)
#               id	-	Camera id (for multi-camera use) (optional, default is 0)
 
proc snapshot { name exp {bcorr 0} {shutter 1} {id 0} } {
 
#
#  Globals    :
#  
#               STATUS	-	Exposure status
#               CFG	-	 
#               CAMERAS	-	Camera id's
#               DEBUG	-	Set to 1 for verbose logging
#               SCOPE	-	Telescope parameters, gui setup
global STATUS CFG CAMERAS DEBUG SCOPE
   if { $STATUS(busy) == 0 } {
    set STATUS(busy) 1
    set camera $CAMERAS($id)
    $camera Expose $exp $shutter   
    set SCOPE(exposure) $exp
    set SCOPE(shutter) $shutter
    set SCOPE(imagetype) OBJECT
    if { $DEBUG } {debuglog "exposing (snapshot)"}
    after [expr $exp*1000+1000] "grabimage $name.fits $bcorr $id"
  }
}





#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : testgeometry
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure uses the Expose method to test that the current set
#  of geometry parameters represents a legal combination.
#
#  Arguments  :
#
#               id	-	Camera id (for multi-camera use) (optional, default is 0)
 
proc testgeometry { {id 0} } {
 
#
#  Globals    :
#  
#               CONFIG	-	GUI configuration
#               CAMERAS	-	Camera id's
global CONFIG CAMERAS
   set exp 0.01
   set shutter 0
   set res "illegal"
   set camera $CAMERAS($id)
   set res [$camera Expose $exp $shutter]
   return $res
}







#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : snapsleep
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure takes an exposure and then sleeps until we expect the
#  exposure is over. At which point it is read out. This routine is 
#  deprecated, as waitforimage is much more useful for normal usage.
#
#  Arguments  :
#
#               name	-	Image file name
#               exp	-	Exposure time in seconds
#               id	-	Camera id (for multi-camera use) (optional, default is 0)
#               shutter	-	Shutter open(1), closed(0) (optional, default is 1)
 
proc snapsleep { name exp {id 0} {shutter 1} } {
 
#
#  Globals    :
#  
#               STATUS	-	Exposure status
#               CAMERAS	-	Camera id's
#               SCOPE	-	Telescope parameters, gui setup
global STATUS CAMERAS SCOPE
    set camera $CAMERAS($id)
    $camera Expose $exp $shutter   
    set SCOPE(exposure) $exp
    set SCOPE(shutter) $shutter
    if { $DEBUG } {debuglog "exposing (snapshot)"}
    set STATUS(busy) 1
    exec sleep [expr ($exp*10+1000)/1000 + 1] 
    grabimage $name.fits
}






#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : flattobuffer
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure takes a flat-field exposure and saves it in an
#  in-memory buffer name FLAT-n. It is intended to be used as part
#  of a calibration library creation sequence.
#
#  Arguments  :
#
#               n	-	Number of frame(s)
#               id	-	Camera id (for multi-camera use) (optional, default is 0)
 
proc flattobuffer { n {id 0} } {
 
#
#  Globals    :
#  
#               STATUS	-	Exposure status
#               CAMERAS	-	Camera id's
#               DEBUG	-	Set to 1 for verbose logging
#               CALS	-	Calibration run parmaeters
#               SCOPE	-	Telescope parameters, gui setup
global STATUS CAMERAS DEBUG CALS SCOPE
    set camera $CAMERAS($id)
    set STATUS(busy) 1
    $camera Expose $CALS(flat,exp) 1  
    set SCOPE(exposure) $CALS(flat,exp)
    set SCOPE(shutter) 1
    set SCOPE(imagetype) FLAT
    if { $DEBUG } {debuglog "exposing (flattobuffer)"}
    set timeout [waitforimage [expr int($CALS(flat,exp))] $id]
    if { $timeout } {
       puts stdout "TIMEOUT"
    } else {
      if { $DEBUG } {debuglog "Reading out..."}
      $camera BufferImage temp
      set STATUS(readout) 0
      store_calib temp FLAT $n 
    }
    set STATUS(busy) 0
}





#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : waitforimage
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure periodically wakes up and checks if the current exposure is
#  ready to be read out yet. If not, it loops around again. If the elapsed time
#  exceeds the expected exposure time (plus a couple of seconds) then it times out.
#
#  Arguments  :
#
#               exp	-	Exposure time in seconds
#               id	-	Camera id (for multi-camera use) (optional, default is 0)
 
proc waitforimage { exp {id 0} } {
 
#
#  Globals    :
#  
#               CAMERAS	-	Camera id's
#               STATUS	-	Exposure status
#               DEBUG	-	Set to 1 for verbose logging
global CAMERAS STATUS DEBUG
  set camera $CAMERAS($id)
  exec sleep 1
  if { $exp == 0 } {set exp 1}
  set STATUS(readout) 0
  set s [$camera read_Status]
  while { $s != 5 && $exp > 0} {
     update 
     exec sleep 1
     incr exp -1
     set s [$camera read_Status]
     if { $DEBUG } {debuglog "waiting $exp $s"}
  }
  set STATUS(readout) 1
  update
  if { $s != 5 } {
     return 1
  }
  return 0
}





#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : darktobuffer
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure takes a dark exposure and saves it in an
#  in-memory buffer name DARK-n. It is intended to be used as part
#  of a calibration library creation sequence.
#
#  Arguments  :
#
#               n	-	Number of frame(s)
#               id	-	Camera id (for multi-camera use) (optional, default is 0)
 
proc darktobuffer { n {id 0} } {
 
#
#  Globals    :
#  
#               STATUS	-	Exposure status
#               CAMERAS	-	Camera id's
#               DEBUG	-	Set to 1 for verbose logging
#               CALS	-	Calibration run parmaeters
#               SCOPE	-	Telescope parameters, gui setup
global STATUS CAMERAS DEBUG CALS SCOPE
    set camera $CAMERAS($id)
    set STATUS(busy) 1
    $camera Expose $CALS(dark,exp) 0  
    set SCOPE(exposure) $CALS(dark,exp)
    set SCOPE(shutter) 0
    set SCOPE(imagetype) DARK
    if { $DEBUG } {debuglog "exposing (darktobuffer)"}
    set timeout [waitforimage [expr int($CALS(dark,exp))] $id]
    if { $timeout } {
       puts stdout "TIMEOUT"
    } else {
      if { $DEBUG } {debuglog "Reading out..."}
      update
      $camera BufferImage temp
      set STATUS(readout) 0
      store_calib temp DARK $n 
    }
    set STATUS(busy) 0
}





#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : zerotobuffer
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure takes a zero length exposure and saves it in an
#  in-memory buffer name ZERO-n. It is intended to be used as part
#  of a calibration library creation sequence.
#
#  Arguments  :
#
#               n	-	Number of frame(s)
#               id	-	Camera id (for multi-camera use) (optional, default is 0)
 
proc zerotobuffer { n {id 0} } {
 
#
#  Globals    :
#  
#               STATUS	-	Exposure status
#               CAMERAS	-	Camera id's
#               DEBUG	-	Set to 1 for verbose logging
#               CALS	-	Calibration run parmaeters
#               SCOPE	-	Telescope parameters, gui setup
global STATUS CAMERAS DEBUG CALS SCOPE
    set camera $CAMERAS($id)
    set STATUS(busy) 1
    $camera Expose $CALS(zero,exp) 0  
    set SCOPE(exposure) $exp
    set SCOPE(shutter) 0
    set SCOPE(imagetype) ZERO
    if { $DEBUG } {debuglog "exposing (zerotobuffer)"}
    set timeout [waitforimage 1 $id]
    if { $timeout } {
       puts stdout "TIMEOUT"
    } else {
      if { $DEBUG } {debuglog "Reading out..."}
      update
      $camera BufferImage temp
      set STATUS(readout) 0
      store_calib temp ZERO $n 
    }
    set STATUS(busy) 0
}





#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : fskytobuffer
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure takes a skyflat-field exposure and saves it in an
#  in-memory buffer name FSKY-n. It is intended to be used as part
#  of a calibration library creation sequence.
#  Arguments  :
#
#               n	-	Number of frame(s)
#               id	-	Camera id (for multi-camera use) (optional, default is 0)
 
proc fskytobuffer { n {id 0} } {
 
#
#  Globals    :
#  
#               STATUS	-	Exposure status
#               CAMERAS	-	Camera id's
#               DEBUG	-	Set to 1 for verbose logging
#               CALS	-	Calibration run parmaeters
#               SCOPE	-	Telescope parameters, gui setup
global STATUS CAMERAS DEBUG CALS SCOPE
    set camera $CAMERAS($id)
    set STATUS(busy) 1
    $camera Expose $CALS(skyflat,exp) 1
    set SCOPE(exposure) $exp
    set SCOPE(shutter) 1
    set SCOPE(imagetype) SKYFLAT
    if { $DEBUG } {debuglog "exposing (fskytobuffer)"}
    set timeout [waitforimage 1 $id]
    if { $timeout } {
       puts stdout "TIMEOUT"
    } else {   
      if { $DEBUG } {debuglog "Reading out..."}
      $camera BufferImage temp
      set STATUS(readout) 0
      store_calib temp FSKY $n 
    }
    set STATUS(busy) 0
}





#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : obstodisk
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure performs the standard exposure operations. The image is
#  saved to a FITS file on disk.
#
#  Arguments  :
#
#               n	-	Number of frame(s)
#               id	-	Camera id (for multi-camera use) (optional, default is 0)
 
proc obstodisk { n {id 0} } {
 
#
#  Globals    :
#  
#               CAMERAS	-	Camera id's
#               STATUS	-	Exposure status
#               SCOPE	-	Telescope parameters, gui setup
#               DEBUG	-	Set to 1 for verbose logging
global CAMERAS STATUS SCOPE DEBUG
    set camera $CAMERAS($id)
    set STATUS(busy) 1
    $camera Expose $SCOPE(exposure) $SCOPE(shutter)
    if { $DEBUG } {debuglog "exposing (obstobuffer)"}
    if { [expr int($SCOPE(exposure))] > 3 } { 
       countdown [expr int($SCOPE(exposure))]
    }
    set timeout [waitforimage [expr int($SCOPE(exposure))] $id]
    if { $timeout } {
       puts stdout "TIMEOUT"
    } else {   
      if { $DEBUG } {debuglog "Reading out..."}
      set d1 [exec date]
      $camera BufferImage tempobs
      set d2 [exec date]
      puts stdout "$d1 $d2"
      set STATUS(readout) 0
      set name "$SCOPE(datadir)/[format "$SCOPE(imagename)" $n].fits"
      saveandshow tempobs $name
   }
}





#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : saveandshow
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure is used to copy an image from an in-memory buffer to 
#  a FITS file on disk. It optionally deletes the file first if
#  overwrite is enabled. It also calls the appropriate routine for 
#  bias correction if that is enabled, and finally displays the image
#  in DS9 if that is enabled.
#
#  Arguments  :
#
#               buffer	-	Name of in-memory image buffer
#               name	-	Image file name
 
proc saveandshow { buffer name } {
 
#
#  Globals    :
#  
#               CAMERAS	-	Camera id's
#               STATUS	-	Exposure status
#               SCOPE	-	Telescope parameters, gui setup
#               DEBUG	-	Set to 1 for verbose logging
global CAMERAS STATUS SCOPE DEBUG
      if { [file exists $name] } {
         if { $SCOPE(overwrite) } {
            exec rm -f $name
         } else {
            set it [ tk_dialog .d "File exists" "The file named\n $name\n already exists, Overwrite it ?" {} -1 No "Yes"]           
            if { $it } {
               exec rm -f $name
            } else {
               set STATUS(busy) 0
               set STATUS(abort) 1
               return
            }
         }
      }
      if { $SCOPE(autocalibrate) } {
          loadcalibrations
          write_calibrated $buffer $SCOPE(exposure) $name 0
      } else {
        if { $SCOPE(autobias) } {
           write_cimage $buffer $SCOPE(exposure) $name
        } else {
           write_image $buffer $name
        }
      }
      if { $SCOPE(autodisplay) } {
        checkDisplay
        exec xpaset -p ds9 file $name
      } 
      set STATUS(busy) 0
}

set LASTTEMP 0.0




#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : loadcalibrations
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This routine loads the best (nearest temperature match) calibration frames
#  if available.
#  The frames are buffered in memory, and can be used  by the write_calibrated
#  c-code call.
#
#  Arguments  :
#
 
proc loadcalibrations { } {
 
#
#  Globals    :
#  
#               LASTTEMP	-	Last temperature used for calibration
#               AVGTEMPS	-	Average temps for plotting
#               DEBUG	-	Set to 1 for verbose logging
#               SCOPE	-	Telescope parameters, gui setup
#               CALS	-	Calibration run parmaeters
global LASTTEMP AVGTEMPS DEBUG SCOPE CALS
  if { $SCOPE(autocalibrate) } {
    if { [expr abs($LASTTEMP-$AVGTEMPS)] > 1.0 } {
       set tnow [expr int($AVGTEMPS)]
       if { [file exists $CALS(zero,dir)/temp$tnow.fits] } {
          if { $DEBUG } {debuglog "loading calibration library data from  $CALS(zero,dir)/temp$tnow.fits"}
          read_image CALIBRATION-ZERO  $CALS(zero,dir)/temp$tnow.fits
       }
       if { [file exists $CALS(dark,dir)/temp$tnow.fits] } {
          if { $DEBUG } {debuglog "loading calibration library data from  $CALS(dark,dir)/temp$tnow.fits"}
          read_image CALIBRATION-DARK  $CALS(dark,dir)/temp$tnow.fits
       }
       if { [file exists $CALS(flat,dir)/temp$tnow.fits] } {
          if { $DEBUG } {debuglog "loading calibration library data from  $CALS(flat,dir)/temp$tnow.fits"}
          read_image CALIBRATION-FLAT  $CALS(flat,dir)/temp$tnow.fits
       }
       if { [file exists $CALS(skyflat,dir)/temp$tnow.fits] } {
          if { $DEBUG } {debuglog "loading calibration library data from  $CALS(skyflat,dir)/temp$tnow.fits"}
          read_image CALIBRATION-FSKY  $CALS(skyflat,dir)/temp$tnow.fits
       }
       set LASTTEMP $AVGTEMPS
    }
  }
}





#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : grabimage
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This routine  readouts the image from the chip, and then writes it
#  to a disk FITS file. Either raw or bias corrected images are supported.
#  
#  Arguments  :
#
#               name	-	Image file name
#               bcorr	-	Bias correction (1=yes) (optional, default is 0)
#               id	-	Camera id (for multi-camera use) (optional, default is 0)
 
proc grabimage { name {bcorr 0} {id 0} } {
 
#
#  Globals    :
#  
#               STATUS	-	Exposure status
#               CAMERAS	-	Camera id's
#               DEBUG	-	Set to 1 for verbose logging
#               SCOPE	-	Telescope parameters, gui setup
global STATUS CAMERAS DEBUG SCOPE
    set camera $CAMERAS($id)
    if { $DEBUG } {debuglog "Reading out..."}
    $camera BufferImage READOUT
    if { [file exists $name] } {
      puts stdout "Overwriting $name"
      exec rm -f $name
    }
    if { $DEBUG } {debuglog "Saving to FITS $name"}
#   write_calibrated temp $name
    if { $bcorr } {
       write_cimage READOUT $SCOPE(exposure) $name
    } else {
       write_image READOUT  $name
    }
    checkDisplay
    exec xpaset -p ds9 file $name
#   show_image test 0
    set STATUS(busy) 0
}





#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : displayimage
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This routine uses the XPA interface to request a shared memory transfer
#  of image data to the DS9 image display tool.
#
#  Arguments  :
#
#               name	-	Image file name
 
proc displayimage { name } {
 
#
#  Globals    :
#  
  set pars [shmem_image $name]
  set cmd "exec xpaset -p ds9  shm array shmid [lindex $pars 0] [lindex $pars 1] \\\[xdim=[lindex $pars 2],ydim=[lindex $pars 3],bitpix=16\\\]"
  eval $cmd
}




#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : abortsequence
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure aborts the current exposure or sequence of exposures.
#  It simply sets the global abort flag and resets the GUI widgets.
#
#  Arguments  :
#
 
proc abortsequence { } {
 
#
#  Globals    :
#  
#               STATUS	-	Exposure status
global STATUS
  set STATUS(abort) 1
  .main.observe configure -text "Observe" -bg gray -relief raised
  .main.abort configure -bg gray -relief sunken -fg LightGray
}





#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : continuousmode
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure continuously calls itself to repeatedly take exposures
#  and auto-display them. It will generally be used to image acquisition
#  and focus applications.
#  This mode of operation will continue until the user clicks "abort"
#
#  Arguments  :
#
#               exp	-	Exposure time in seconds
#               n	-	Number of frame(s) (optional, default is 9999)
#               id	-	Camera id (for multi-camera use) (optional, default is 0)
 
proc continuousmode { exp {n 9999} {id 0} } {
 
#
#  Globals    :
#  
#               STATUS	-	Exposure status
#               CAMERAS	-	Camera id's
global STATUS CAMERAS
   if { $STATUS(abort) } {set STATUS(abort) 0 ; return}
   if { $STATUS(busy) } {after 100 continuousmode $exp $n}
   .main.observe configure -text "continuous" -bg green -relief sunken
   .main.abort configure -bg orange -relief raised -fg black
   update
   set camera $CAMERAS($id)
   $camera Expose $exp 1
   $camera BufferImage READOUT
   displayimage READOUT
   incr n -1
   if { $n > 0 } {
      after 10 continuousmode $exp $n
   } else {
      .main.observe configure -text "Observe" -bg gray -relief raised
      .main.abort configure -bg gray -relief sunken -fg LightGray
   }
}




#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : observe
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This stub routine responds to user selections on the observe menu.
#
#  Arguments  :
#
#               op	-	Operation specifier
#               id	-	Camera id (for multi-camera use) (optional, default is 0)
 
proc observe { op {id 0} } {
 
#
#  Globals    :
#  
#               SCOPE	-	Telescope parameters, gui setup
global SCOPE
  switch $op {
      region {acquisitionmode}
      multiple {continuousmode $SCOPE(exposure) 9999 $id}
  }
}






#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : waitfortemp
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure is used to wait until the required temperature is 
#  reached (within 1 degree). At that point it calls the routine
#  specified. It is used by the calibration library generation routines.
#
#  Arguments  :
#
#               t	-	Temperature (degrees c)
#               cmd	-	Command to execute after timed wait (optional, default is bell)
 
proc waitfortemp { t {cmd bell} } {
 
#
#  Globals    :
#  
#               AVGTEMPS	-	Average temps for plotting
#               WAITCMD	-	Command to execute after a wait
global AVGTEMPS WAITCMD 
   if { $cmd != "wait" } {set  WAITCMD "$cmd"}
   if { [expr abs($t-$AVGTEMPS)] < 1.0 } {
       eval $WAITCMD
   } else {
       after 5000 waitfortemp $t wait
   }
}





#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : darklibrary
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure generates a library of dark frames. It repeatedly 
#  steps thru a set of temperatures, and call dakrframes at each
#  point to take the exposures.
#
#  Arguments  :
#
#               t	-	Temperature (degrees c)
#               high	-	Maximum temperature for a calibration run
#               n	-	Number of frame(s)
 
proc darklibrary { t high n } {
 
#
#  Globals    :
#  
   if { $t < $high } {
      wm title .countdown "countdown - Acquiring darks at $t deg C"
      setpoint set $t
      waitfortemp $t "darkframes $n $t $high"
   }
}






#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : flatlibrary
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure generates a library of flat-field frames. It repeatedly 
#  steps thru a set of temperatures, and call flatframes at each
#  point to take the exposures.
#
#  Arguments  :
#
#               t	-	Temperature (degrees c)
#               high	-	Maximum temperature for a calibration run
#               n	-	Number of frame(s)
 
proc flatlibrary { t high n } {
 
#
#  Globals    :
#  
   if { $t < $high } {
      wm title .countdown "countdown - Acquiring flat-fields at $t deg C"
      setpoint set $t
      waitfortemp $t "flatframes $n $t $high"
   }
}




#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : skyflatlibrary
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure generates a library of sky flat frames. It repeatedly 
#  steps thru a set of temperatures, and call skyflatframes at each
#  point to take the exposures.
#
#  Arguments  :
#
#               t	-	Temperature (degrees c)
#               high	-	Maximum temperature for a calibration run
#               n	-	Number of frame(s)
 
proc skyflatlibrary { t high n } {
 
#
#  Globals    :
#  
   if { $t < $high } {
      wm title .countdown "countdown - Acquiring skyflat-fields at $t deg C"
      setpoint set $t
      waitfortemp $t "skyflatframes $n $t $high"
   }
}





#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : zerolibrary
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure generates a library of zero frames. It repeatedly 
#  steps thru a set of temperatures, and call zeroframes at each
#  point to take the exposures.
#
#  Arguments  :
#
#               t	-	Temperature (degrees c)
#               high	-	Maximum temperature for a calibration run
#               n	-	Number of frame(s)
 
proc zerolibrary { t high n } {
 
#
#  Globals    :
#  
   if { $t < $high } {
      wm title .countdown "countdown - Acquiring zeroes at $t deg C"
      setpoint set $t
      waitfortemp $t "zeroframes $n $t $high"
   }
}





#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : flatframes
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure takes a set of n flat-field frames and stores them in 
#  memory buffers.
#
#  Arguments  :
#
#               n	-	Number of frame(s)
#               t	-	Temperature (degrees c)
#               high	-	Maximum temperature for a calibration run
 
proc flatframes { n  t high } {
 
#
#  Globals    :
#  
#               STATUS	-	Exposure status
#               CALS	-	Calibration run parmaeters
global STATUS CALS
   set i 0
   while { $i < $n } {
      set FRAME $i
      countdown [expr $CALS(flat,exp)]
      puts stdout "flat frame $i"
      flattobuffer $i $CALS(flat,exp)
      incr i 1
   }
   if { [file exists  $CALS(flat,dir)/temp$t.fits] } {
      exec rm -f $CALS(flat,dir)/temp$t.fits
   }
   if { [file exists $CALS(zero,dir)/temp$t.fits] } {
      read_image CALIBRATION-ZERO  $CALS(zero,dir)/temp$t.fits
   }
   if { [file exists $CALS(dark,dir)/temp$t.fits] } {
      read_image CALIBRATION-DARK  $CALS(dark,dir)/temp$t.fits
   }
   write_fimage $CALS(flat,dir)/temp$t.fits $CALS(flat,exp) 0
   incr t 1
   flatlibrary $t $high $n 
   countdown off
}




#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : skyflatframes
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure takes a set of n skyflat-field frames and stores them in 
#  memory buffers.
#
#  Arguments  :
#
#               n	-	Number of frame(s)
#               t	-	Temperature (degrees c)
#               high	-	Maximum temperature for a calibration run
 
proc skyflatframes { n t high } {
 
#
#  Globals    :
#  
#               STATUS	-	Exposure status
#               CALS	-	Calibration run parmaeters
global STATUS CALS
   set i 0
   while { $i < $n } {
      set FRAME $i
      countdown [expr $CALS(skyflat,exp)]
      puts stdout "flat frame $i"
      fskytobuffer $i $CALS(skyflat,exp)
      incr i 1
   }
   if { [file exists  $CALS(skyflat,dir)/temp$t.fits] } {
      exec rm -f $CALS(skyflat,dir)/temp$t.fits
   }
   if { [file exists $CALS(zero,dir)/temp$t.fits] } {
      read_image CALIBRATION-ZERO  $CALS(zero,dir)/temp$t.fits
   }
   if { [file exists $CALS(dark,dir)/temp$t.fits] } {
      read_image CALIBRATION-DARK  $CALS(dark,dir)/temp$t.fits
   }
   write_simage $CALS(skyflat,dir)/temp$t.fits $CALS(skyflat,exp) 0
   incr t 1
   skyflatlibrary $t $high $n
   countdown off
}




#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : darkframes
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure takes a set of n dark frames and stores them in 
#  memory buffers.
#
#  Arguments  :
#
#               n	-	Number of frame(s)
#               t	-	Temperature (degrees c)
#               high	-	Maximum temperature for a calibration run
 
proc darkframes { n t high } {
 
#
#  Globals    :
#  
#               STATUS	-	Exposure status
#               FRAME	-	Frame number in a sequence
#               CALS	-	Calibration run parmaeters
global STATUS FRAME CALS
   set i 1
   while { $i <= $n } {
      set FRAME $i
      countdown [expr $CALS(dark,exp)]
      puts stdout "dark frame $i"
      darktobuffer $i 
      incr i 1
   }
   if { [file exists  $CALS(dark,dir)/temp$t.fits] } {
      exec rm -f $CALS(dark,dir)/temp$t.fits
   }
   if { [file exists $CALS(zero,dir)/temp$t.fits] } {
      read_image CALIBRATION-ZERO  $CALS(zero,dir)/temp$t.fits
   }
   write_dimage $CALS(dark,dir)/temp$t.fits $CALS(dark,exp) 0
   incr t 1
   darklibrary $t $high $n 
   countdown off
}




#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : zeroframes
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure takes a set of n zero frames and stores them in 
#  memory buffers.
#
#  Arguments  :
#
#               n	-	Number of frame(s)
#               t	-	Temperature (degrees c)
#               high	-	Maximum temperature for a calibration run
 
proc zeroframes { n t high } {
 
#
#  Globals    :
#  
#               STATUS	-	Exposure status
#               FRAME	-	Frame number in a sequence
#               CALS	-	Calibration run parmaeters
global STATUS FRAME CALS
   set i 1
   while { $i <= $n } {
      set FRAME $i
      countdown 1
      puts stdout "zero frame $i"
      zerotobuffer $i
      incr i 1
   }
   incr t 1
   if { [file exists  $CALS(zero,dir)/temp$t.fits] } {
      exec rm -f $CALS(zero,dir)/temp$t.fits
   }
   write_zimage $CALS(zero,dir)/temp$t.fits $CALS(zero,exp) 1
   zerolibrary $t $high $n 
   countdown off
}





#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : caltest
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This is a test routine to exercise the calibration routines
#
#  Arguments  :
#
#               n	-	Number of frame(s)
#               exp	-	Exposure time in seconds
#               t	-	Temperature (degrees c) (optional, default is -30)
 
proc caltest { n exp {t -30} } {
 
#
#  Globals    :
#  
   catch {exec rm zero$n.fits dark$n.fits}
   setpoint set $t
   zeroframes $n 1 $t $t
   write_zimage zero$n.fits $exp 1 
   darkframes $n $exp $t $t
   write_dimage dark$n.fits $exp 1 
}




#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : opencalibrate
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This routine is a stub to support the calibrate menu entries
#
#  Arguments  :
#
#               type	-	Calibration type (flat,dark,sky,zero)
 
proc opencalibrate { type} {
 
#
#  Globals    :
#  
   wm deiconify .cal
   .cal.$type.sel invoke
}




#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : savestate
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This routine saves the current configuration to ~/.apgui.tcl
#  from whence it will be autoloaded on subsequent runs
#
#  Arguments  :
#
#            
 
proc savestate { } {
 
#
#  Globals    :
#  
global CONFIG SCOPE ACQREGION LASTBIN OBSPARS env
   set fout [open $env(HOME)/.apgui.tcl w]
   foreach i [array names CONFIG] {
      puts $fout "catch \{set CONFIG($i) \"$CONFIG($i)\"\}"
   }
   foreach i [array names ACQREGION] {
      puts $fout "set ACQREGION($i) \"$ACQREGION($i)\""
   }
   foreach i [array names SCOPE] {
      puts $fout "set SCOPE($i) \"$SCOPE($i)\""
   }
   foreach i [array names LASTBIN] {
      puts $fout "set LASTBIN($i) \"$LASTBIN($i)\""
   }
   foreach i [array names OBSPARS] {
      puts $fout "set OBSPARS($i) \"$OBSPARS($i)\""
   }
   foreach i [array names CALS] {
      puts $fout "set CALS($i) \"$CALS($i)\""
   }
   close $fout
}





#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : createcalibrations
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure calls the appropriate calibration library routine
#
#  Arguments  :
#
#               type	-	Calibration type (flat,dark,sky,zero)
 
proc createcalibrations { type } {
 
#
#  Globals    :
#  
#               CALS	-	Calibration run parmaeters
#               CCDID	-	Camera id
global CALS CCDID
   set dt [expr $CALS($type,tmax)-$CALS($type,tmin)+1]
   set t [format %.2f [expr $dt * $CALS($type,navg) * (9 + $CALS($type,exp))]]
   set it [ tk_dialog .d "$type calibrations" "Click OK to run a $type calibration library\nsequence of $CALS($type,navg) frames. This will take approx. $t seconds" {} -1 OK "Cancel to select new mode"]      
   if { $it } {
      switch $type {
          zero { zerolibrary $CALS(zero,tmin) $CALS(zero,tmax) $CALS(zero,navg) }
          dark { darklibrary $CALS(dark,tmin) $CALS(dark,tmax) $CALS(dark,navg) $CALS(dark,exp) }
          flat { flatlibrary $CALS(flat,tmin) $CALS(flat,tmax) $CALS(flat,navg) $CALS(flat,exp) }
          skyflat { skyflatlibrary $CALS(skyflat,tmin) $CALS(skyflat,tmax) $CALS(skyflat,navg) $CALS(skyflat,exp) }
      }
   }
}

#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : loadcalibrate
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure loads the a calibration frame chosen by the user
#
#  Arguments  :
#
#               type	-	Calibration type (flat,dark,skyflat,zero)

proc loadcalibrate { type } {

#
#  Globals    :
#  
#               CALS	-	Calibration run parmaeters
global CALS SCOPE
   set d $CALS($type,dir)
   set cal [tk_getOpenFile -initialdir $d -filetypes {{{Calibrations} {.fits}}}]   
   switch $type {
      dark    { read_image CALIBRATION_DARK $cal }
      zero    { read_image CALIBRATION_ZERO $cal }
      skyflat { read_image CALIBRATION_FSKY $cal }
      flat    { read_image CALIBRATION_FLAT $cal }
   }
   set SCOPE(autocalibrate) 0
}





#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : acquisitionmode
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure controls the specification of a sub-image region using
#  the DS9 image display tool.
#
#  Arguments  :
#
 
proc  acquisitionmode { } {
 
#
#  Globals    :
#  
#               ACQREGION	-	Sub-frame region coordinates
#               CONFIG	-	GUI configuration
global ACQREGION CONFIG
  set it [ tk_dialog .d "Acquisition region" "Click New to define a new region,\n OK to use the current region " {} -1 OK "New"]      
  if {$it} {
    catch {
      exec xpaset -p ds9 regions deleteall
      exec xpaset -p ds9 regions box $ACQREGION(xs) $ACQREGION(ys) $ACQREGION(xe) $ACQREGION(ye)
    }
    set it [tk_dialog .d "Edit region" "Resize/Move the region in the\n image display tool then click OK" {} -1 "OK"]
    set reg [split [exec xpaget ds9 regions] \n]
    foreach i $reg {
     if { [string range $i 0 8] == "image;box" } {
        set r [lrange [split $i ",()"] 1 4]
        set ACQREGION(xs) [expr int([lindex $r 0] - [lindex $r 2]/2)]
        set ACQREGION(ys) [expr int([lindex $r 1] - [lindex $r 3]/2)]
        set ACQREGION(xe) [expr int([lindex $r 0] + [lindex $r 2]/2)]
        set ACQREGION(ye) [expr int([lindex $r 1] + [lindex $r 3]/2)]
        puts stdout "selected region $r"
     }
    }
  } 
  set CONFIG(geometry.StartCol) [expr $ACQREGION(xs)]
  set CONFIG(geometry.StartRow) [expr $ACQREGION(ys)]
  set CONFIG(geometry.NumCols) [expr $ACQREGION(xe)-$ACQREGION(xs)+1]
  set CONFIG(geometry.NumRows) [expr $ACQREGION(ye)-$ACQREGION(ys)+1]
}


#
#  Define a default sub-region
#  
set ACQREGION(xs) 200
set ACQREGION(xe) 64
set ACQREGION(ys) 200
set ACQREGION(ye) 64




#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : toggle
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This routine opens/closes any window based upon it current open/closed status
#
#  Arguments  :
#
#               win	-	Widget id of window
 
proc toggle { win } {
 
#
#  Globals    :
#  
   if { [winfo ismapped $win] } { 
      wm withdraw $win
   } else {
      wm deiconify $win
   }
}



set FRAME 1
set STATUS(readout) 0




#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : countdown
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This routine manages a countdown window. The window displays the 
#  current frame number, and seconds remaining.
#
#  Arguments  :
#
#               time	-	Countdown time in seconds
 
proc countdown { time } {
 
#
#  Globals    :
#  
#               FRAME	-	Frame number in a sequence
#               STATUS	-	Exposure status
global FRAME STATUS
  if { $time == "off" || $STATUS(abort) } {
     wm withdraw .countdown
     return
  }
  .countdown.f configure -text $FRAME
  .countdown.t configure -text $time
  incr time -1
  if { [winfo ismapped .countdown] == 0 } {
     wm deiconify .countdown
     wm geometry .countdown +20+20
  }
  if { $time > -1 } {
     update
     after 900 countdown $time
  } else {
     if { $STATUS(readout) } {
       .countdown.t configure -text "READING"
     } else {
       wm withdraw .countdown
     }
  }
}




#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : startsequence
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This routine manages a sequence of exposures. It updates bias columns
#  specifications in case they have been changed, then it loops thru
#  a set of frames, updating the countdown window, and calling obstodisk to 
#  do the actual exposures.
#
#  Arguments  :
#
 
proc startsequence { } {
 
#
#  Globals    :
#  
#               SCOPE	-	Telescope parameters, gui setup
#               OBSPARS	-	Default observation parameters
#               FRAME	-	Frame number in a sequence
#               STATUS	-	Exposure status
#               DEBUG	-	Set to 1 for verbose logging
global SCOPE OBSPARS FRAME STATUS DEBUG
   set OBSPARS($SCOPE(exptype)) "$SCOPE(exposure) $SCOPE(numframes) $SCOPE(shutter)"
   set STATUS(abort) 0
   if { $SCOPE(lobias) > 0 && $SCOPE(hibias) > 0 } {
      set_biascols $SCOPE(lobias) $SCOPE(hibias)
   }
   .main.observe configure -text "working" -bg green -relief sunken
   .main.abort configure -bg orange -relief raised -fg black
   set i 1
   while { $i <= $SCOPE(numframes) && $STATUS(abort) == 0 } {
      set FRAME $i
      countdown [expr int($SCOPE(exposure))]
      if { $DEBUG} {debuglog "$SCOPE(exptype) frame $i"}
      obstodisk $i 
      incr i 1
   }
   .main.observe configure -text "Observe" -bg gray -relief raised
   .main.abort configure -bg gray -relief sunken -fg LightGray
   countdown off
}

#
#  Update status display
#
showstatus "Building user interface"
set SCOPE(driftdelay) 300000
set SCOPE(driftrows) 512

#
#  Create countdown window widgets
#
set f "Helvetica -30 bold"
toplevel .countdown -bg orange -width 535 -height 115
label .countdown.lf -text "Frame # " -bg orange -font $f
label .countdown.lt -text "Seconds : " -bg orange -font $f
label .countdown.f -text "???" -bg orange -font $f
label .countdown.t -text "???" -bg orange -font $f
place .countdown.lf -x 10 -y 40
place .countdown.f -x 140 -y 40
place .countdown.lt -x 230 -y 40
place .countdown.t -x 380 -y 40
wm withdraw .countdown


#
#  Create main window and its menus
#
wm title . "Apogee Camera Control"
frame .mbar -width 520 -height 30 -bg gray
menubutton .mbar.file -text "File" -fg black -bg gray -menu .mbar.file.m
menubutton .mbar.edit -text "Edit" -fg black -bg gray -menu .mbar.edit.m
menubutton .mbar.observe -text "Observe" -fg black -bg gray -menu .mbar.observe.m
menubutton .mbar.calib -text "Calibrate" -fg black -bg gray -menu .mbar.calib.m
menubutton .mbar.help -text "Help" -fg black -bg gray -menu .mbar.help.m
menubutton .mbar.tools -text "Tools" -fg black -bg gray -menu .mbar.tools.m
pack .mbar
place .mbar.file -x 0 -y 0
place .mbar.edit -x 40 -y 0
place .mbar.observe -x 80 -y 0
place .mbar.calib -x 150 -y 0
place .mbar.tools -x 210 -y 0
place .mbar.help -x 460 -y 0
menu .mbar.file.m 
menu .mbar.edit.m
menu .mbar.observe.m
menu .mbar.calib.m
menu .mbar.tools.m
menu .mbar.help.m
#.mbar.file.m add command -label "Open" -command fileopen
.mbar.file.m add command -label "Save" -command filesave
#.mbar.file.m add command -label "Save As" -command filesaveas
.mbar.file.m add command -label "Exit" -command shutdown
.mbar.edit.m add command -label "Properties" -command showconfig
.mbar.observe.m add command -label "Single-frame" -command "observe single"
.mbar.observe.m add command -label "Continuous" -command "observe multiple"
.mbar.observe.m add command -label "Snap-region" -command "observe region"
.mbar.observe.m add command -label "Drift-scan" -command "toggle .drift"
### NYI .mbar.calib.m add command -label "Focus" -command "opencalibrate focus"
.mbar.calib.m add command -label "Load Dark calibration" -command "loadcalibrate dark"
.mbar.calib.m add command -label "Load Flat calibration" -command "loadcalibrate flat"
.mbar.calib.m add command -label "Load SkyFlat calibration" -command "loadcalibrate skyflat"
.mbar.calib.m add command -label "Load Zero calibration" -command "loadcalibrate zero"
.mbar.calib.m add command -label "Build Dark library" -command "opencalibrate dark"
.mbar.calib.m add command -label "Build Flat library" -command "opencalibrate flat"
.mbar.calib.m add command -label "Build SkyFlat library" -command "opencalibrate sky"
.mbar.calib.m add command -label "Build Zero library" -command "opencalibrate zero"
### NYI .mbar.calib.m add command -label "Calculate WCS" -command "calcwcs"
### NYI .mbar.calib.m add command -label "Collimation" -command "observe collimate"
### NYI .mbar.tools.m add command -label "Auto-locate" -command autoIdentify
.mbar.tools.m add command -label "DSS" -command getDSS
.mbar.tools.m add command -label "GSC" -command getGSC
### NYI .mbar.tools.m add command -label "USNO" -command getUSNO
### NYI .mbar.tools.m add command -label "RNGC" -command getRNGC
.mbar.help.m add command -label "Users Guide" -command {exec netscape file:/opt/apogee/doc/user-guide.html &}


#
#  Initialize telescope/user variables
#
source $TKAPOGEE/scripts/tele_init.tcl
frame .main -bg gray -width 520 -height 300
pack .main -side bottom
set iy 10
foreach item "target ra dec observer site latitude longitude" {
   label .main.l$item -bg gray -fg black -text $item
   place .main.l$item -x 300 -y $iy
   entry .main.v$item -bg white -fg black -relief sunken -width 12 -textvariable SCOPE($item)
   place .main.v$item -x 400 -y $iy
   incr iy 27  
}
button .main.ssite -bg gray -fg black -text "?" -font "Helvetica -10 bold" -command "wm deiconify .psite"
place .main.ssite -x 491 -y 118


#
#  Create main observation management widgets
#
#
SpinBox .main.exposure -width 7 -label "Exposure (in seconds) : " -font fixed -labelfont "fixed"  -range "0.0 1048.75 1" -textvariable SCOPE(exposure)
place .main.exposure -x 20 -y 20
SpinBox .main.numexp -width 12 -label "Number of frames : " -font fixed  -labelfont "fixed"  -range "1 1000 1" -textvariable SCOPE(numframes)
place .main.numexp -x 20 -y 50
set opts "Object Focus Acquire Flat SkyFlat Dark Zero"
ComboBox .main.exptype -width 15 -label "Exposure type : " -font fixed -labelfont "fixed"  -values "$opts" -textvariable SCOPE(exptype)
place .main.exptype -x 20 -y 80
set SCOPE(exptype) Object
button .main.seldir -width 24 -text "Configure data directory" -command "choosedir data data"
place .main.seldir -x 20 -y 110
label .main.lname -bg gray -fg black -text "File name :"
place .main.lname -x 20 -y 140
entry .main.imagename -width 16 -bg white -fg black -textvariable SCOPE(imagename)
place .main.imagename -x 90 -y 140
.main.imagename insert 0 test
button .main.observe -width 10 -height 2 -text "Observe" -bg gray -command startsequence
button .main.abort -width 10 -height 2 -text "Abort" -bg gray -command abortsequence
place .main.observe -x 20 -y 170
place .main.abort -x 117 -y 170
checkbutton .main.autodisplay -bg gray  -text "Automatic display" -variable SCOPE(autodisplay)
place .main.autodisplay -x 20 -y 217
checkbutton .main.overwrite -bg gray  -text "Overwrite files" -variable SCOPE(overwrite)
place .main.overwrite -x 170 -y 217
checkbutton .main.autocalib -bg gray  -text "Automatic calibration (uses library frames)" -variable SCOPE(autocalibrate)
place .main.autocalib -x 20 -y 271
set SCOPE(lobias) 0
set SCOPE(hibias) 0
entry .main.lobias -bg white -fg black -width 6 -textvariable SCOPE(lobias)
entry .main.hibias -bg white -fg black -width 6 -textvariable SCOPE(hibias)
place .main.lobias -x 220 -y 244
place .main.hibias -x 280 -y 244

checkbutton .main.autobias -bg gray  -text "Automatic bias subtraction" -variable SCOPE(autobias)
place .main.autobias -x 20 -y 244
.main.abort configure -relief sunken -fg LightGray
set SCOPE(autodisplay) 1
set SCOPE(autobias) 0
set SCOPE(autocalibrate) 0
set SCOPE(overwrite) 0
set STATUS(abort) 0
set STATUS(readout) 0
toplevel .psite -bg gray -width 225 -height 695
listbox .psite.l -width 30 -height 40
pack .psite.l
wm withdraw .psite
set fin [open $TKAPOGEE/config/sites.dat r]
set i 0
while { $i < 23 } {gets $fin rec ; incr i 1}
set i 0
while { [gets $fin rec] > -1 } {
   set s [split $rec ";"]
   .psite.l insert end [lindex $s 0]
   set SITES($i) [string trim "[lindex $s 1] | [lindex $s 2]" ]
   incr i 1
}
close $fin
bind  .psite.l <Double-1> {pastelocation}
wm title .psite "double-click to select"




#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : pastelocation
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure updates the users longitude/latitude when they select
#  their location in the site list.
#
#  Arguments  :
#
 
proc pastelocation { } {
 
#
#  Globals    :
#  
#               SITES	-	Site long/lat info
global SITES 
  set l [.psite.l curselection]
  set ll [split $SITES($l) |]
  set lat [lindex $ll 0]
  set lon [lindex $ll 1]
  .main.vsite delete 0 end
  .main.vlatitude delete 0 end
  .main.vlongitude delete 0 end
  .main.vlatitude insert 0 "[join [lrange $lat 0 2] :] [lindex $lat 3]"
  .main.vlongitude insert 0 "[join [lrange $lon 0 2] :] [lindex $lon 3]" 
  .main.vsite insert 0 "[.psite.l get $l]"
  wm withdraw .psite
}


#
#  Load all the help texts
#
showstatus "Loading online help"

source  $TKAPOGEE/scripts/tcl_aphelp.tcl
source  $TKAPOGEE/scripts/tcl_cathelp.tcl
source  $TKAPOGEE/scripts/tcl_telehelp.tcl
source  $TKAPOGEE/scripts/tcl_calhelp.tcl


#
#  Create the properties panels
#
showstatus "Loading camera properties"
toplevel .p 
wm title .p  "Properties (Alt-p to open/close window)"
wm geometry .p +20+90
wm withdraw .p
NoteBook .p.props -width 520 -height 300
.p.props insert 1 Telescope -text Telescope
.p.props insert 2 System -text System
.p.props insert 3 Geometry -text Geometry
.p.props insert 4 Temperature -text Temperature
.p.props insert 5 CCD -text CCD
.p.props insert 6 Filter -text Filter
.p.props insert 7 Catalogs -text Catalogs
pack .p.props
set spc "                "
set xsize 220
set ysize 30


#
#  Add all the actual properties to the panels. These are defined
#  in terms of type, range, default, and so forth.
#
showstatus "Configuring user interface"

set fin [open $TKAPOGEE/config/tcl_config.dat r]
while { [gets $fin rec] > -1 } {
   catch {
   if { [lsearch "Telescope System Geometry Temperature CCD Filter Catalogs" $rec] > -1 } {
      set idx [expr [lsearch "Telescope System Geometry Temperature CCD Filter Catalogs" $rec] +1]
      set f [.p.props getframe $rec]
      set subsys [string tolower $rec]
      set ix 0
      set iy 0
      showstatus "Configuring user interface ($subsys)"
   } else {
      set name   [string tolower [lindex $rec 0]]
      set lname "$name[string range $spc 0 [expr 16-[string length $name]]]"
      set cname $subsys.[lindex $rec 0]
      set range   [lindex $rec 1]
      set default [lindex $rec 2]
      if { $range == "READONLY" } {
         label $f.$name -text "$lname" -fg black -bg gray -relief sunken -width 27
      }
      if { $range == "URL" } {
         button $f.$name -text "$lname" -fg black -bg gray -command "choosedir catalogs $name" -width 27
      }
      if { $range == "ONOFF" } {
         ComboBox $f.$name -label "$lname" -helptext "$APHELP($name)" -labelfont "fixed" -bg gray -values "Off On" -width 10 -textvariable CONFIG($cname)
         $f.$name setvalue first
      }
      if { [llength [split $range :]] > 1 } {
         set vmin [lindex [split $range :] 0]
         set vmax [lindex [split $range :] 1]
         SpinBox $f.$name -label "$lname" -helptext "$APHELP($name)" -labelfont "fixed"  -range "$vmin $vmax 1" -width 10 -textvariable CONFIG($cname)
         set CONFIG($cname) $default
      }
      if { [llength [split $range "|"]] > 1 } {
         set opts [split $range "|"]
         ComboBox $f.$name -label "$lname" -helptext "$APHELP($name)" -labelfont "fixed"  -values "$opts" -width 10 -textvariable CONFIG($cname)
         set CONFIG($cname) $default
      }
      place $f.$name -x [expr 10+$xsize*$ix] -y [expr 10+$ysize*$iy]
      incr ix 1
      if { $ix > 1 } {
         set ix 0
         incr iy 1
      }
    }
   }
}
close $fin

#
#  Create the calibrations library control GUI
#

toplevel .cal -bg gray -width 500 -height -250
wm  title .cal "Calibrations (Alt-c to open/close window)"
foreach t "zero dark flat skyflat" {
   frame .cal.$t -bg gray
   label .cal.$t.l -bg gray -text $t -width 8 
   checkbutton .cal.$t.auto -text automatic -variable CALS($t,auto)
   button .cal.$t.sel -text "Select library" -bg gray -command "choosedir calibrations $t"
   SpinBox .cal.$t.tmin -label "   min temp" -helptext "$APHELP(caltmin)" -labelfont "fixed"  -range "-40 40 1" -width 4 -textvariable CALS($t,tmin)
   SpinBox .cal.$t.tmax -label "   max temp" -helptext "$APHELP(caltmax)" -labelfont "fixed"  -range "-40 40 1" -width 4 -textvariable CALS($t,tmax)
   SpinBox .cal.$t.navg -label "   num. frames" -helptext "$APHELP(calnavg)" -labelfont "fixed"  -range "1 100 1" -width 4 -textvariable CALS($t,navg)
   SpinBox .cal.$t.exp -label "   exposure" -helptext "$APHELP(calexp)" -labelfont "fixed"  -range "0.02 65535. .01" -width 4 -textvariable CALS($t,exp)
   set CALS($t,tmin) -30
   set CALS($t,tmax) 10
   set CALS($t,navg) 10
   pack .cal.$t.l -side left -fill both -expand yes
   pack .cal.$t.auto -side left -fill both -expand yes
   pack .cal.$t.sel -side left -fill both -expand yes
   pack .cal.$t.tmin -side left -fill both -expand yes
   pack .cal.$t.tmax -side left -fill both -expand yes
   pack .cal.$t.navg -side left -fill both -expand yes
   pack .cal.$t.exp -side left -fill both -expand yes
   pack .cal.$t -side top -fill both -expand yes
}
set CALS(dark,exp) 10
set CALS(flat,exp) 0.5
set CALS(skyflat,exp) 0.5
foreach t "zero dark flat skyflat" {
   button .cal.run$t -text "Create $t calibrations library" -bg gray -command "createcalibrations $t"
   pack .cal.run$t -side top -fill both -expand yes
}
button .cal.close -text "close" -bg yellow -command "wm withdraw .cal"
pack .cal.close -side top -fill both -expand yes

#
#  Create the drift-scan control GUI
#

showstatus "Loading driftscan properties"
toplevel .drift 
wm title .drift "Drift-scan (Alt-d to open/close window)"
wm geometry .drift 365x327+20+247 
wm withdraw .drift
wm title .drift "Drift-scan control"
label .drift.msg -text "Drift-scan mode is still experimental!"
place .drift.msg -x 10 -y 10
label .drift.mmeas -text "Measured per-line drift rate at current DEC is "
place .drift.mmeas -x 10 -y 40
entry .drift.vmeas -bg white -fg black -width 8 -textvariable SCOPE(driftsamp)
place .drift.vmeas -x 290 -y 40
button .drift.calib -text "Calculate per-line rate for DEC=+00:00:00" -command driftcalib
place .drift.calib -x 10 -y 70
label .drift.mbase -text "Per-line drift rate for DEC=+00:00:00 is "
place .drift.mbase -x 10 -y 100
entry .drift.vbase -bg white -fg black -width 8 -textvariable SCOPE(driftdelay)
place .drift.vbase -x 290 -y 100
label .drift.mrows -text "Number of rows for drift image "
place .drift.mrows -x 10 -y 130
entry .drift.vrows -bg white -fg black -width 8 -textvariable SCOPE(driftrows)
place .drift.vrows -x 290 -y 130
button .drift.calc -text "Calculate duration and per-line rate in microsecs" -command driftcalc
place .drift.calc -x 10 -y 160
label .drift.mdur -text "Total image duration (hh:mm:ss) =  "
place .drift.mdur -x 10 -y 200
label .drift.vdur -textvariable SCOPE(driftexp)
place .drift.vdur -x 290 -y 200
label .drift.mmsec -text "Microsecsond delay per row =  "
place .drift.mmsec -x 10 -y 230
label .drift.vmsec -textvariable SCOPE(driftdcalc)
place .drift.vmsec -x 290 -y 230
button .drift.go -text "Start drift scan exposure" -width 46 -height 3 -bg gray -command "driftscan 0 0"
place .drift.go -x 10 -y 260

#
#  Set up the default structures for temperaure control/plotting
#

set TIMES "0"
set SETPOINTS "0.0"
set AVGTEMPS "0.0"
set i -60
set xdata ""
set ydata ""
set ysetp ""
while { $i < 0 } {
  lappend xdata $i
  lappend ydata $AVGTEMPS
  lappend ysetp $SETPOINTS
  incr i 1
}


#
#  Create the temperature history graphic
#

set f [.p.props getframe Temperature]
set TEMPWIDGET $f.plot
graph $f.plot -title "Temperature" -width 500 -height 220
$f.plot element create Temp
$f.plot element create SetPoint
$f.plot element configure Temp -symbol none -xdata $xdata -ydata $ydata
$f.plot element configure SetPoint -color red -symbol none -xdata $xdata -ydata $ysetp
place $f.plot -x 0 -y 60
wm geometry .cal +20+445
wm withdraw .cal
update


#
#  Call the camera setup code, and the telescope setup code
#
showstatus "Initializing camera"
source  $TKAPOGEE/scripts/camera_init.tcl
source  $TKAPOGEE/scripts/tele_init.tcl

#
#  Synchronize the widgets with the relevant camera CONFIG values
#

foreach i [array names CONFIG] {
   foreach s "CCD System" {
     if { [string tolower $s] == [lindex [split $i .] 0] } {
       set id [string tolower [lindex [split $i .] 1]]
       set w ".p.props.f$s.$id"
       if { [winfo exists $w] } {
          if { [winfo class $w] == "Label" } {
            puts stdout "$i $s"
            $w configure -text "$id = $CONFIG($i)" -fg black
          }
#          if { [winfo class $w] == "Frame" } {
#            puts stdout "$i $s"
#            set CONFIG($id) $CONFIG($i)
#          }
       }
     }
   }  
}





#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : driftscan
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure manages driftscan observations. All the heavy lifting is
#  done by the C/C++ code of course.
#
#  Arguments  :
#
#               nrow	-	Number of rows to readout (optional, default is 0)
#               delay	-	Per-row delay in microseconds (optional, default is 0)
#               nblock	-	Number of rows to read per cycle (optional, default is 1)
#               shutter	-	Shutter open(1), closed(0) (optional, default is 1)
#               id	-	Camera id (for multi-camera use) (optional, default is 0)
 
proc driftscan { {nrow 0} {delay 0} {nblock 1} {shutter 1} {id 0} } {
 
#
#  Globals    :
#  
#               CAMERAS	-	Camera id's
#               SCOPE	-	Telescope parameters, gui setup
#               DEBUG	-	Set to 1 for verbose logging
global CAMERAS SCOPE DEBUG
  if { $delay == 0 } {set delay $SCOPE(driftdcalc)}
  if { $nrow == 0 } {set nrow $SCOPE(driftrows)}
  if { $DEBUG } {debuglog  "Drift scan using delay = $delay, rows = $nrow"}
  set camera $CAMERAS($id)
  $camera configure -m_TDI 1
  $camera Expose [expr $delay/1000] $shutter
  $camera BufferDriftScan drift $delay $nrow $nblock
  set name "$SCOPE(datadir)/$SCOPE(imagename).fits"
  saveandshow drift $name
  $camera configure -m_TDI 0
}





#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : driftcalib
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#
#  This procedure calculates the equatorial drift rate based upon a 
#  rate measured by the user at an arbritary (hopefully accurate) known
#  DEC.
#
#  Arguments  :
#
 
proc driftcalib { } {
 
#
#  Globals    :
#  
#               SCOPE	-	Telescope parameters, gui setup
global SCOPE
   set delay $SCOPE(driftsamp)
   set d [dms_to_radians [.main.vdec get]]
   set fac [expr cos($d)]
   set SCOPE(driftdelay) [expr int($delay*$fac)]
}




#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : driftcalc
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure calculates the drift rate in microseconds. It presumes that
#  the equatorial rate has already been calculated.
#
#
#  Arguments  :
#
 
proc driftcalc { } {
 
#
#  Globals    :
#  
#               SCOPE	-	Telescope parameters, gui setup
#               CAMSTATUS	-	Current values of camera variables
global SCOPE CAMSTATUS
   set delay $SCOPE(driftdelay)
   set d [dms_to_radians [.main.vdec get]]
   set fac [expr cos($d)]
   set SCOPE(driftdcalc) [expr int($delay/$fac)]
   set t [tlabel [expr $SCOPE(driftdcalc)/1000000.*($CAMSTATUS(NumY)+$SCOPE(driftrows))/3600./12.*3.14159]]
   set SCOPE(driftexp) $t
}

set DRIFTDELAY 0



#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : focustest
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure takes a focus exposure. This consists of taking a series
#  of exposures, and shifting the charge on the ccd in between each.
#  In addition, the focus is also altered between each exposure.
#  The resulting image can be automatically analsed to determine 
#  optimum focus.
#  This is an example of using TDI mode, without writing any c/c++ code, the 
#  applications of this technique are legion.....
#
#  Arguments  :
#
#               name	-	Image file name
#               exp	-	Exposure time in seconds
#               nstep	-	Number of steps in focus
#               nshift	-	Number of rows to shift per focus step
#               id	-	Camera id (for multi-camera use) (optional, default is 0)
 
proc focustest { name exp nstep nshift {id 0} } {
 
#
#  Globals    :
#  
#               CAMERAS	-	Camera id's
#               DEBUG	-	Set to 1 for verbose logging
#               CAMSTATUS	-	Current values of camera variables
global CAMERAS DEBUG CAMSTATUS
  set camera $CAMERAS($id)
  $camera configure -m_TDI 1
  $camera Expose 0.02 0
  set istep 1
  set ishift 0
  while { $ishift < $CAMSTATUS(NumY) } {
     $camera DigitizeLine
     incr ishift 1
  }
  while { $istep <= $nstep } {
    set it [tk_dialog .d "Focus exposure" "Move to focus position $istep\n then click OK" {} -1 "Cancel" "OK"]
    if { $it } {
      if { $istep == $nstep } {set nshift [expr $nshift*2] }
      $camera write_ForceShutterOpen 1 
      exec sleep $exp
      $camera write_ForceShutterOpen 0
      set ishift 0
      while { $ishift < $nshift } {
         $camera DigitizeLine
         incr ishift 1
      }
    } else { 
       set istep $nstep
    }
    incr istep 1
  }
  $camera configure -m_TDI 0
  $camera BufferImage READOUT
  if { $DEBUG } {debuglog "Saving to FITS $name"}
  write_image READOUT $name.fits
}




set CCDID 0




#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : watchconfig
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure "watches" the variables in the CONFIG array. The
#  value of these variables may be altered by the user using the 
#  properties panels. This procedure ensures that the C++ instance
#  variables get updated in sync
#
#  Arguments  :
#
#               arr	-	Array name
#               var	-	tcl variable name
#               op	-	Operation specifier
 
proc watchconfig { arr var op } {
 
#
#  Globals    :
#  
#               CONFIG	-	GUI configuration
#               CAMERAS	-	Camera id's
#               CCAPI	-	Generic C++ object names
#               CCAPIW	-	C++ writable instance variables
#               CCDID	-	Camera id
#               LASTBIN	-	Last binning factor used
global CONFIG CAMERAS CCAPI CCAPIW CCDID LASTBIN
#      puts stdout "$arr $var $op"
      switch $var {
           temperature.Target { setpoint set $CONFIG($var) }
           ccd.Gain    { catch {set_gain $CONFIG(gain) $CCDID} }
      }
      foreach i [array names CCAPIW] {
         if { [string range $i 2 end] == $CCAPI($var) } {
            set camera $CAMERAS($CCDID)
#            puts stdout "setting $i"
            if { $var == "geometry.BinX" } {
               set newcols [expr $CONFIG(geometry.NumCols)*$LASTBIN(x)/$CONFIG(geometry.BinX)]
               set LASTBIN(x) $CONFIG($var)
               set CONFIG(geometry.NumCols) $newcols
            }
            if { $var == "geometry.BinY" } {
               set newrows [expr $CONFIG(geometry.NumRows)*$LASTBIN(y)/$CONFIG(geometry.BinY)]
               set LASTBIN(y) $CONFIG($var)
               set CONFIG(geometry.NumRows) $newrows
            }
            $camera configure -$i $CONFIG($var)
         }
      }
      if { [testgeometry] == 0 } {
         .p.props.fGeometry configure -bg orange
         bell
      } else {
         .p.props.fGeometry configure -bg gray
      }
}




#---------------------------------------------------------------------------
#---------------------------------------------------------------------------
#
#  Procedure  : watchscope
#
#---------------------------------------------------------------------------
#  Author     : Dave Mills (rfactory@theriver.com)
#  Version    : 0.3
#  Date       : Jan-14-2001
#  Copyright  : The Random Factory, Tucson AZ
#  License    : GNU GPL
#  Changes    :
#
#  This procedure updates the global observation parameter defaults
#  so that they can be saved/restored as exit/startup (NYI)
#  Arguments  :
#
#               arr	-	Array name
#               var	-	tcl variable name
#               op	-	Operation specifier
 
proc watchscope { arr var op } {
 
#
#  Globals    :
#  
#               SCOPE	-	Telescope parameters, gui setup
#               OBSPARS	-	Default observation parameters
global SCOPE OBSPARS
    switch $var { 
        exptype {
                 set SCOPE(exposure)  [lindex $OBSPARS($SCOPE($var)) 0]
                 set SCOPE(numframes) [lindex $OBSPARS($SCOPE($var)) 1]
                 set SCOPE(shutter)   [lindex $OBSPARS($SCOPE($var)) 2]
                }
    }
}

#
#  Set defaults for observation parameters
#

set OBSPARS(Object) "1.0 1 1"
set OBSPARS(Focus)  "0.1 1 1"
set OBSPARS(Acquire) "1.0 1 1"
set OBSPARS(Flat)    "1.0 10 1"
set OBSPARS(Dark)    "100.0 10 0"
set OBSPARS(Zero)    "0.01 10 0"
set OBSPARS(Skyflat) "0.1 10 1"

set LASTBIN(x) 1
set LASTBIN(y) 1

#
#  Do the actual setup of the GUI, to sync it with the camera status
#

showstatus "Loading camera API"
inspectapi CCameraIO
refreshcamdata
trace variable CONFIG w watchconfig
trace variable SCOPE w watchscope


#
#  Reset to the last used configuration if available
#

if { [file exists $env(HOME)/.apgui.tcl] } {
   source $env(HOME)/.apgui.tcl
}

#
#  Fix the date
#

set SCOPE(obsdate) [join "[lrange $now 1 2] [lindex $now 4]" -]  

#
#  Start monitoring the temperature
#

monitortemp
wm withdraw .status
wm geometry . +20+30

#
#  Link ALT key sequences to pop-up the various windows
#

bind . <Alt-p> {toggle .p}
bind . <Alt-c> {toggle .cal}
bind . <Alt-d> {toggle .drift}
bind .p <Alt-p> {toggle .p}
bind .p <Alt-c> {toggle .cal}
bind .p <Alt-d> {toggle .drift}
bind .cal <Alt-p> {toggle .p}
bind .cal <Alt-c> {toggle .cal}
bind .cal <Alt-d> {toggle .drift}
bind .drift <Alt-p> {toggle .p}
bind .drift <Alt-c> {toggle .cal}
bind .drift <Alt-d> {toggle .drift}


focus .

#
#  Stop the user from destroying the windows by accident
#

wm protocol .countdown WM_DELETE_WINDOW {wm withdraw .countdown}
wm protocol .psite  WM_DELETE_WINDOW {wm withdraw .psite}
wm protocol .status WM_DELETE_WINDOW {wm withdraw .status}
wm protocol .drift  WM_DELETE_WINDOW {wm withdraw .drift}
wm protocol .cal    WM_DELETE_WINDOW {wm withdraw .cal}
wm protocol .p      WM_DELETE_WINDOW {wm withdraw .p}
wm protocol .       WM_DELETE_WINDOW {wm withdraw .status}

#ap7p  set_biascols 1 7, set bic 4
#kx260 set_biascols 1 5, set bic 2
