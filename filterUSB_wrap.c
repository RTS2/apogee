/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3u-20040523-0413 (Alpha 5)
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__)
#       if defined(_MSC_VER)
#               if defined(STATIC_LINKED)
#                       define SWIGEXPORT(a) a
#               else
#                       define SWIGEXPORT(a) __declspec(dllexport) a
#               endif
#       else
#               if defined(__BORLANDC__)
#                       define SWIGEXPORT(a) a _export
#               else
#                       define SWIGEXPORT(a) a
#       endif
#endif
#else
#       define SWIGEXPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct swig_type_info {
  char  *name;                 
  void *(*converter)(void *);
  char  *str;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

#ifdef SWIG_NOINCLUDE
SWIGEXPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGEXPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGEXPORT(void *) SWIG_TypeCast(swig_type_info *, void *);
#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti)
{
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
 l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty)
{
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  while (s) {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
	s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      return s;
    }
    s = s->next;
  }
  return 0;
}

/* Cast a pointer (needed for C++ inheritance */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) 
{
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(void *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

#endif

#ifdef __cplusplus
}
#endif



/*
 * $Header: /cvs/projects/SWIG/Lib/tcl/swigtcl8.swg,v 1.8 2000/09/02 16:25:29 beazley Exp $
 * 
 * swigtcl8.swg
 */

#include <tcl.h>
#include <stdlib.h>
#include <stdarg.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef SWIG_NOINCLUDE
SWIGEXPORT(int) SWIG_ConvertPtrFromString(Tcl_Interp *, char *, void **, swig_type_info *);
SWIGEXPORT(int) SWIG_ConvertPtr(Tcl_Interp *, Tcl_Obj *, void **, swig_type_info *);
SWIGEXPORT(void) SWIG_MakePtr(char *, void *, swig_type_info *);
SWIGEXPORT(Tcl_Obj *) SWIG_NewPointerObj(void *, swig_type_info *);
SWIGEXPORT(int) SWIG_GetArgs(Tcl_Interp *, int, Tcl_Obj *CONST [], const char *, ...);
SWIGEXPORT(char *) SWIG_PointerTypeFromString(char *c);
#else

/* Convert a pointer value */
SWIGRUNTIME(int)
SWIG_ConvertPtrFromString(Tcl_Interp *interp, char *c, void **ptr, swig_type_info *ty)
{
  unsigned long p;
  register int d;
  swig_type_info *tc;
  p = 0;
  /* Pointer values must start with leading underscore */
  if (*c != '_') {
    *ptr = (void *) 0;
    if (strcmp(c,"NULL") == 0) return TCL_OK;
    Tcl_SetResult(interp,"Type error. Expected a pointer", TCL_STATIC);
    return TCL_ERROR;
  }
  c++;
  /* Extract hex value from pointer */
  while ((d = *c)) {
    if ((d >= '0') && (d <= '9'))
      p = (p << 4) + (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      p = (p << 4) + (d - ('a'-10));
    else
      break; 
    c++;
  }
  *ptr = (void *) p;
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) {
      Tcl_SetResult(interp,"Type error. Expected ", TCL_STATIC);
      Tcl_AppendElement(interp, ty->name);
      return TCL_ERROR;
    }
    *ptr = SWIG_TypeCast(tc,(void *)p);
  }
  return TCL_OK;
}


/* Convert a pointer value */
SWIGRUNTIME(int)
SWIG_ConvertPtr(Tcl_Interp *interp, Tcl_Obj *oc, void **ptr, swig_type_info *ty)
{
  return SWIG_ConvertPtrFromString(interp, Tcl_GetStringFromObj(oc,NULL), ptr, ty);
}


/* Convert a pointer value */
SWIGRUNTIME(char *)
SWIG_PointerTypeFromString(char *c) {
  char d;
  /* Pointer values must start with leading underscore */
  if (*c != '_') {
    return 0;
  }
  c++;
  /* Extract hex value from pointer */
  while (d = *c) {
    if (!(((d >= '0') && (d <= '9')) || ((d >= 'a') && (d <= 'f')))) break;
    c++;
  }
  return c;
}

/* Take a pointer and convert it to a string */
SWIGRUNTIME(void) 
SWIG_MakePtr(char *c, void *ptr, swig_type_info *ty) {
  static char hex[17] = "0123456789abcdef";
  unsigned long p, s;
  char result[24], *r; 
  r = result;
  p = (unsigned long) ptr;
  if (p > 0) {
    while (p > 0) {
      s = p & 0xf;
      *(r++) = hex[s];
      p = p >> 4;
    }
    *r = '_';
    while (r >= result)
      *(c++) = *(r--);
    strcpy (c, ty->name);
  } else {
    strcpy (c, "NULL");
  }
}

/* Create a new pointer object */
SWIGRUNTIME(Tcl_Obj *)
SWIG_NewPointerObj(void *ptr, swig_type_info *type) {
  char result[256];
  Tcl_Obj *robj;
  SWIG_MakePtr(result,ptr,type);
  robj = Tcl_NewStringObj(result,-1);
  return robj;
}

/* Get arguments */
SWIGRUNTIME(int)
SWIG_GetArgs(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[], const char *fmt, ...)
{
  int        argno = 0, opt = 0, tempi;
  int        us = 0;
  double     tempd;
  const char *c;
  va_list    ap;
  void      *vptr;
  swig_type_info *ty;

  va_start(ap,fmt);
  for (c = fmt; (*c && (*c != ':')); c++,argno++) {
    if (*c == '|') {
      opt = 1;
      c++;
    }
    if (argno >= (objc-1)) {
      if (!opt) {
	Tcl_SetResult(interp,"Wrong # args. ", TCL_STATIC);
	goto argerror;
      } else {
	va_end(ap);
	return TCL_OK;
      }
    }
    vptr = va_arg(ap,void *);
    if (vptr) {
      us = 0;
      if (*c == 'u') {
	us = 1;
	c++;
      }
      switch(*c) {
      case 'i':
      case 'l':
      case 'h':
      case 'b':
	if (Tcl_GetIntFromObj(interp,objv[argno+1],&tempi) != TCL_OK) goto argerror;
	if (*c == 'i') *((int *)vptr) = tempi;
	else if (*c == 'l') *((long *)vptr) = tempi;
	else if (*c == 'h') *((short*)vptr) = tempi;
	else if (*c == 'b') *((unsigned char *)vptr) = tempi;
	break;
      case 'f':
      case 'd':
	if (Tcl_GetDoubleFromObj(interp,objv[argno+1],&tempd) != TCL_OK) goto argerror;
	if (*c == 'f') *((float *) vptr) = tempd;
	else if (*c == 'd') *((double*) vptr) = tempd;
	break;
      case 's':
	if (*(c+1) == '#') {
	  int *vlptr = (int *) va_arg(ap, void *);
	  *((char **) vptr) = Tcl_GetStringFromObj(objv[argno+1], vlptr);
	  c++;
	} else {
	  *((char **)vptr) = Tcl_GetStringFromObj(objv[argno+1],NULL);
	}
	break;
      case 'c':
	*((char *)vptr) = *(Tcl_GetStringFromObj(objv[argno+1],NULL));
	break;
      case 'p':
	ty = (swig_type_info *) va_arg(ap, void *);
	if (SWIG_ConvertPtr(interp, objv[argno+1], (void **) vptr, ty) == TCL_ERROR) goto argerror;
	break;
      case 'o':
	*((Tcl_Obj **)vptr) = objv[argno+1];
	break;
      default:
	break;
      }
    }
  }
  if ((objc-1) > argno) {
    Tcl_SetResult(interp,"Wrong # args.", TCL_STATIC);
    goto argerror;
  }
  va_end(ap);
  return TCL_OK;
  
 argerror:
  {
    char temp[32];
    sprintf(temp,"%d", argno);
    Tcl_AppendResult(interp,strchr(fmt,':'), " argument ", temp, NULL);
    va_end(ap);
    return TCL_ERROR;
  }
}

#endif

/* Structure for command table */
typedef struct {
  const char *name;
  int       (*wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
  ClientData  clientdata;
} swig_command_info;

/* Structure for variable linking table */
typedef struct {
  const char *name;
  void *addr;
  char * (*get)(ClientData, Tcl_Interp *, char *, char *, int);
  char * (*set)(ClientData, Tcl_Interp *, char *, char *, int);
} swig_var_info;


#ifdef __cplusplus
}
#endif


/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_Apn_FilterStatus swig_types[0] 
#define  SWIGTYPE_p_unsigned_long swig_types[1] 
#define  SWIGTYPE_p_Apn_Filter swig_types[2] 
#define  SWIGTYPE_p_long swig_types[3] 
#define  SWIGTYPE_p_CApnFilterWheel swig_types[4] 
#define  SWIGTYPE_p_unsigned_short swig_types[5] 
static swig_type_info *swig_types[7];

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    Filter_usb_Init
#define SWIG_name    "filter_usb"
#define SWIG_prefix  ""
#define SWIG_namespace ""

#ifdef __cplusplus
extern "C" {
#endif
#ifdef MAC_TCL
#pragma export on
#endif
SWIGEXPORT(int) Filter_usb_Init(Tcl_Interp *);
#ifdef MAC_TCL
#pragma export off
#endif
#ifdef __cplusplus
}
#endif

#include "ApnFilterWheel.h"
/* object.swg
 *
 * Tcl8.x - Object oriented runtime functions
 */

typedef int (*swig_wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);

typedef struct swig_method { 
  const char     *name;
  swig_wrapper   method;
} swig_method;

typedef struct swig_attribute {
  const char     *name;
  swig_wrapper   getmethod;
  swig_wrapper   setmethod;
} swig_attribute;
  
typedef struct swig_class {
  const char        *name;
  swig_type_info  **type;
  swig_wrapper      constructor;
  void             (*destructor)(void *);
  swig_method      *methods;
  swig_attribute   *attributes;
} swig_class;

typedef struct swig_instance {
  Tcl_Obj       *thisptr;
  void          *thisvalue;
  swig_class   *classptr;
  int            destroy;
} swig_instance;

static void SwigObjectDelete(ClientData clientData) {
  swig_instance *si = (swig_instance *) clientData;
  if (si->destroy) {
    if (si->classptr->destructor) {
      (si->classptr->destructor)(si->thisvalue);
    }
  }
  Tcl_DecrRefCount(si->thisptr);
  free(si);
}

/* Function to invoke object methods given an instance */
static int
SwigMethodCmd(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST _objv[])
{
  char *method, *attrname;
  swig_instance  *inst = (swig_instance *) clientData;
  swig_method    *meth;
  swig_attribute *attr;
  Tcl_Obj         *oldarg;
  Tcl_Obj         **objv;
  int              rcode;

  objv = (Tcl_Obj **) _objv;
  if (objc < 2) {
    Tcl_SetResult(interp,"wrong # args.", TCL_STATIC);
    return TCL_ERROR;
  }
  meth = inst->classptr->methods;
  method = Tcl_GetStringFromObj(objv[1],NULL);

  /* Check for methods */
  while (meth && meth->name) {
    if (strcmp(meth->name,method) == 0) {
      oldarg = objv[1];
      objv[1] = inst->thisptr;
      Tcl_IncrRefCount(inst->thisptr);
      rcode = (*meth->method)(clientData,interp,objc,objv);
      objv[1] = oldarg;
      Tcl_DecrRefCount(inst->thisptr);
      return rcode;
    }
    meth++;
  }
  /* Check class methods for a match */
  if (strcmp(method,"cget") == 0) {
    if (objc < 3) {
      Tcl_SetResult(interp,"wrong # args.", TCL_STATIC);
      return TCL_ERROR;
    }
    attrname = Tcl_GetStringFromObj(objv[2],NULL);
    attr = inst->classptr->attributes;
    while (attr && attr->name) {
      if ((strcmp(attr->name, attrname) == 0) && (attr->getmethod)) {
	oldarg = objv[1];
	objv[1] = inst->thisptr;
	Tcl_IncrRefCount(inst->thisptr);
	rcode = (*attr->getmethod)(clientData,interp,2, objv);
	objv[1] = oldarg;
	Tcl_DecrRefCount(inst->thisptr);
	return rcode;
      }
      attr++;
    }
    if (strcmp(attrname, "-this") == 0) {
      Tcl_SetObjResult(interp, Tcl_DuplicateObj(inst->thisptr));
      return TCL_OK;
    }
    Tcl_SetResult(interp,"Invalid attribute.", TCL_STATIC);
    return TCL_ERROR;
  } else if (strcmp(method, "configure") == 0) {
    int i;
    if (objc < 4) {
      Tcl_SetResult(interp,"wrong # args.", TCL_STATIC);
      return TCL_ERROR;
    }
    i = 2;
    while (i < objc) {
      attrname = Tcl_GetStringFromObj(objv[i],NULL);
      attr = inst->classptr->attributes;
      while (attr && attr->name) {
	if ((strcmp(attr->name, attrname) == 0) && (attr->setmethod)) {
	  oldarg = objv[i];
	  objv[i] = inst->thisptr;
	  Tcl_IncrRefCount(inst->thisptr);
	  rcode = (*attr->setmethod)(clientData,interp,3, &objv[i-1]);
	  objv[i] = oldarg;
	  Tcl_DecrRefCount(inst->thisptr);
	  if (rcode != TCL_OK) return rcode;
	  i+=2;
	  break;
	}
	attr++;
      }
      if (inst->classptr->attributes && !(attr->name)) {
	Tcl_SetResult(interp,"Invalid attribute name.", TCL_STATIC);
	return TCL_ERROR;
      }
    }
    return TCL_OK;
  } else {
    Tcl_SetResult(interp,"Invalid method. Must be one of: configure cget ", TCL_STATIC);
    meth = inst->classptr->methods;
    while (meth && meth->name) {
      Tcl_AppendElement(interp, meth->name);
      meth++;
    }
    return TCL_ERROR;
  }

  
}

/* Function to create objects */
static int 
SwigObjectCmd(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
{
    Tcl_Obj          *newObj = 0;
    void             *thisvalue = 0;
    swig_instance   *newinst = 0;
    swig_class      *classptr = (swig_class *) clientData;
    swig_wrapper     cons = 0;
    char             *name = 0;
    int               firstarg = 0;
    int               thisarg = 0;
    int               destroy = 1; 
    Tcl_CmdInfo       ci;

    if (!classptr) {
      Tcl_SetResult(interp,"swig: internal runtime error. No class object defined.", TCL_STATIC);
      return TCL_ERROR;
    }
    cons = classptr->constructor;
    if (objc > 1) {
      char *s = Tcl_GetStringFromObj(objv[1],NULL);
      if (strcmp(s,"-this") == 0) {
	thisarg = 2;
	cons = 0;
      } else if (strcmp(s,"-args") == 0) {
	firstarg = 1;
      } else if (objc == 2) {
	firstarg = 1;
	name = s;
      } else if (objc >= 3) {
	char *s1;
	name = s;
	s1 = Tcl_GetStringFromObj(objv[2],NULL);
	if (strcmp(s1,"-this") == 0) {
	  thisarg = 3;
	  cons = 0;
	} else {
	  firstarg = 1;
	}
      }
    }
    if (cons) {
      int result;
      result = (*cons)(0, interp, objc-firstarg, &objv[firstarg]);
      if (result != TCL_OK) {
	return result;
      }
      newObj = Tcl_DuplicateObj(Tcl_GetObjResult(interp));
      if (!name) name = Tcl_GetStringFromObj(newObj,NULL);
    } else if (thisarg > 0) {
      if (thisarg < objc) {
	destroy = 0;
	newObj = Tcl_DuplicateObj(objv[thisarg]);
	if (!name) name = Tcl_GetStringFromObj(newObj,NULL);
      } else {
	Tcl_SetResult(interp,"wrong # args.", TCL_STATIC);
	return TCL_ERROR;
      }
    } else {
      Tcl_SetResult(interp,"No constructor available.", TCL_STATIC);
      return TCL_ERROR;
    }
    if (!Tcl_GetCommandInfo(interp,name,&ci)) {
      if (SWIG_ConvertPtr(interp,newObj, (void **) &thisvalue, *(classptr->type)) == TCL_ERROR) {
	Tcl_DecrRefCount(newObj);
	return TCL_ERROR;
      }
      newinst = (swig_instance *) malloc(sizeof(swig_instance));
      newinst->thisptr = newObj;
      Tcl_IncrRefCount(newObj);
      newinst->thisvalue = thisvalue;
      newinst->classptr = classptr;
      newinst->destroy = destroy;
      Tcl_CreateObjCommand(interp,name, SwigMethodCmd, (ClientData) newinst, SwigObjectDelete);
      return TCL_OK;
    } else {
      Tcl_SetResult(interp,"Object name already exists!", TCL_STATIC);
      return TCL_ERROR;
    }
}

static int
_wrap_new_CApnFilterWheel(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    CApnFilterWheel *result ;
    
    if (SWIG_GetArgs(interp, objc, objv,":new_CApnFilterWheel ") == TCL_ERROR) return TCL_ERROR;
    result = (CApnFilterWheel *)new CApnFilterWheel();
    Tcl_SetObjResult(interp,SWIG_NewPointerObj((void *) result,SWIGTYPE_p_CApnFilterWheel));
    return TCL_OK;
}

static int
_wrap_delete_CApnFilterWheel(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    CApnFilterWheel *arg0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:delete_CApnFilterWheel self ",&arg0, SWIGTYPE_p_CApnFilterWheel) == TCL_ERROR) return TCL_ERROR;
    delete arg0;
    return TCL_OK;
}

static int
_wrap_CApnFilterWheel_Init(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    CApnFilterWheel *arg0 ;
    Apn_Filter *arg1 ;
    unsigned long arg2 ;
    bool result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"ppl:CApnFilterWheel_Init self FilterType DeviceNum ",&arg0, SWIGTYPE_p_CApnFilterWheel,&arg1, SWIGTYPE_p_Apn_Filter,&arg2) == TCL_ERROR) return TCL_ERROR;
    result = (bool )arg0->Init(*arg1,arg2);
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

static int
_wrap_CApnFilterWheel_Close(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    CApnFilterWheel *arg0 ;
    bool result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:CApnFilterWheel_Close self ",&arg0, SWIGTYPE_p_CApnFilterWheel) == TCL_ERROR) return TCL_ERROR;
    result = (bool )arg0->Close();
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

static int
_wrap_CApnFilterWheel_GetVendorId(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    CApnFilterWheel *arg0 ;
    unsigned short *arg1 ;
    bool result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pp:CApnFilterWheel_GetVendorId self VendorId ",&arg0, SWIGTYPE_p_CApnFilterWheel,&arg1, SWIGTYPE_p_unsigned_short) == TCL_ERROR) return TCL_ERROR;
    result = (bool )arg0->GetVendorId(arg1);
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

static int
_wrap_CApnFilterWheel_GetProductId(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    CApnFilterWheel *arg0 ;
    unsigned short *arg1 ;
    bool result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pp:CApnFilterWheel_GetProductId self ProductId ",&arg0, SWIGTYPE_p_CApnFilterWheel,&arg1, SWIGTYPE_p_unsigned_short) == TCL_ERROR) return TCL_ERROR;
    result = (bool )arg0->GetProductId(arg1);
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

static int
_wrap_CApnFilterWheel_GetDeviceId(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    CApnFilterWheel *arg0 ;
    unsigned short *arg1 ;
    bool result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pp:CApnFilterWheel_GetDeviceId self DeviceId ",&arg0, SWIGTYPE_p_CApnFilterWheel,&arg1, SWIGTYPE_p_unsigned_short) == TCL_ERROR) return TCL_ERROR;
    result = (bool )arg0->GetDeviceId(arg1);
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

static int
_wrap_CApnFilterWheel_GetUsbFirmwareRev(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    CApnFilterWheel *arg0 ;
    char *arg1 ;
    long *arg2 ;
    bool result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"psp:CApnFilterWheel_GetUsbFirmwareRev self FirmwareRev BufferLength ",&arg0, SWIGTYPE_p_CApnFilterWheel,&arg1,&arg2, SWIGTYPE_p_long) == TCL_ERROR) return TCL_ERROR;
    result = (bool )arg0->GetUsbFirmwareRev(arg1,arg2);
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

static int
_wrap_CApnFilterWheel_GetWheelType(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    CApnFilterWheel *arg0 ;
    Apn_Filter *arg1 ;
    bool result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pp:CApnFilterWheel_GetWheelType self WheelType ",&arg0, SWIGTYPE_p_CApnFilterWheel,&arg1, SWIGTYPE_p_Apn_Filter) == TCL_ERROR) return TCL_ERROR;
    result = (bool )arg0->GetWheelType(arg1);
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

static int
_wrap_CApnFilterWheel_GetWheelModel(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    CApnFilterWheel *arg0 ;
    char *arg1 ;
    long *arg2 ;
    bool result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"psp:CApnFilterWheel_GetWheelModel self WheelDescr BufferLength ",&arg0, SWIGTYPE_p_CApnFilterWheel,&arg1,&arg2, SWIGTYPE_p_long) == TCL_ERROR) return TCL_ERROR;
    result = (bool )arg0->GetWheelModel(arg1,arg2);
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

static int
_wrap_CApnFilterWheel_GetStatus(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    CApnFilterWheel *arg0 ;
    Apn_FilterStatus *arg1 ;
    bool result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pp:CApnFilterWheel_GetStatus self FilterStatus ",&arg0, SWIGTYPE_p_CApnFilterWheel,&arg1, SWIGTYPE_p_Apn_FilterStatus) == TCL_ERROR) return TCL_ERROR;
    result = (bool )arg0->GetStatus(arg1);
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

static int
_wrap_CApnFilterWheel_GetMaxPositions(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    CApnFilterWheel *arg0 ;
    unsigned long *arg1 ;
    bool result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pp:CApnFilterWheel_GetMaxPositions self MaxPositions ",&arg0, SWIGTYPE_p_CApnFilterWheel,&arg1, SWIGTYPE_p_unsigned_long) == TCL_ERROR) return TCL_ERROR;
    result = (bool )arg0->GetMaxPositions(arg1);
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

static int
_wrap_CApnFilterWheel_SetPosition(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    CApnFilterWheel *arg0 ;
    unsigned long arg1 ;
    bool result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pl:CApnFilterWheel_SetPosition self Position ",&arg0, SWIGTYPE_p_CApnFilterWheel,&arg1) == TCL_ERROR) return TCL_ERROR;
    result = (bool )arg0->SetPosition(arg1);
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

static int
_wrap_CApnFilterWheel_GetPosition(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    CApnFilterWheel *arg0 ;
    unsigned long *arg1 ;
    bool result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"pp:CApnFilterWheel_GetPosition self Position ",&arg0, SWIGTYPE_p_CApnFilterWheel,&arg1, SWIGTYPE_p_unsigned_long) == TCL_ERROR) return TCL_ERROR;
    result = (bool )arg0->GetPosition(arg1);
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
}

static void swig_delete_CApnFilterWheel(void *obj) {
    delete (CApnFilterWheel *) obj;
}
static swig_method swig_CApnFilterWheel_methods[] = {
    {"Init", _wrap_CApnFilterWheel_Init}, 
    {"Close", _wrap_CApnFilterWheel_Close}, 
    {"GetVendorId", _wrap_CApnFilterWheel_GetVendorId}, 
    {"GetProductId", _wrap_CApnFilterWheel_GetProductId}, 
    {"GetDeviceId", _wrap_CApnFilterWheel_GetDeviceId}, 
    {"GetUsbFirmwareRev", _wrap_CApnFilterWheel_GetUsbFirmwareRev}, 
    {"GetWheelType", _wrap_CApnFilterWheel_GetWheelType}, 
    {"GetWheelModel", _wrap_CApnFilterWheel_GetWheelModel}, 
    {"GetStatus", _wrap_CApnFilterWheel_GetStatus}, 
    {"GetMaxPositions", _wrap_CApnFilterWheel_GetMaxPositions}, 
    {"SetPosition", _wrap_CApnFilterWheel_SetPosition}, 
    {"GetPosition", _wrap_CApnFilterWheel_GetPosition}, 
    {0,0}
};
static swig_attribute swig_CApnFilterWheel_attributes[] = {
    {0,0,0}
};
static swig_class _wrap_class_CApnFilterWheel = { "CApnFilterWheel", &SWIGTYPE_p_CApnFilterWheel,_wrap_new_CApnFilterWheel, swig_delete_CApnFilterWheel, swig_CApnFilterWheel_methods, swig_CApnFilterWheel_attributes };

static swig_command_info swig_commands[] = {
    { SWIG_prefix "new_CApnFilterWheel", _wrap_new_CApnFilterWheel, NULL},
    { SWIG_prefix "delete_CApnFilterWheel", _wrap_delete_CApnFilterWheel, NULL},
    { SWIG_prefix "CApnFilterWheel_Init", _wrap_CApnFilterWheel_Init, NULL},
    { SWIG_prefix "CApnFilterWheel_Close", _wrap_CApnFilterWheel_Close, NULL},
    { SWIG_prefix "CApnFilterWheel_GetVendorId", _wrap_CApnFilterWheel_GetVendorId, NULL},
    { SWIG_prefix "CApnFilterWheel_GetProductId", _wrap_CApnFilterWheel_GetProductId, NULL},
    { SWIG_prefix "CApnFilterWheel_GetDeviceId", _wrap_CApnFilterWheel_GetDeviceId, NULL},
    { SWIG_prefix "CApnFilterWheel_GetUsbFirmwareRev", _wrap_CApnFilterWheel_GetUsbFirmwareRev, NULL},
    { SWIG_prefix "CApnFilterWheel_GetWheelType", _wrap_CApnFilterWheel_GetWheelType, NULL},
    { SWIG_prefix "CApnFilterWheel_GetWheelModel", _wrap_CApnFilterWheel_GetWheelModel, NULL},
    { SWIG_prefix "CApnFilterWheel_GetStatus", _wrap_CApnFilterWheel_GetStatus, NULL},
    { SWIG_prefix "CApnFilterWheel_GetMaxPositions", _wrap_CApnFilterWheel_GetMaxPositions, NULL},
    { SWIG_prefix "CApnFilterWheel_SetPosition", _wrap_CApnFilterWheel_SetPosition, NULL},
    { SWIG_prefix "CApnFilterWheel_GetPosition", _wrap_CApnFilterWheel_GetPosition, NULL},
    { SWIG_prefix "CApnFilterWheel", SwigObjectCmd, &_wrap_class_CApnFilterWheel},
    {0, 0, 0}
};

static swig_var_info swig_variables[] = {
    {0,0,0,0}
};

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_Apn_FilterStatus[] = {{"_p_Apn_FilterStatus", 0, "Apn_FilterStatus *"},{"_p_Apn_FilterStatus"},{0}};
static swig_type_info _swigt__p_unsigned_long[] = {{"_p_unsigned_long", 0, "unsigned long *"},{"_p_unsigned_long"},{0}};
static swig_type_info _swigt__p_Apn_Filter[] = {{"_p_Apn_Filter", 0, "Apn_Filter *"},{"_p_Apn_Filter"},{0}};
static swig_type_info _swigt__p_long[] = {{"_p_long", 0, "long *"},{"_p_long"},{0}};
static swig_type_info _swigt__p_CApnFilterWheel[] = {{"_p_CApnFilterWheel", 0, "CApnFilterWheel *"},{"_p_CApnFilterWheel"},{0}};
static swig_type_info _swigt__p_unsigned_short[] = {{"_p_unsigned_short", 0, "unsigned short *"},{"_p_unsigned_short"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_Apn_FilterStatus, 
_swigt__p_unsigned_long, 
_swigt__p_Apn_Filter, 
_swigt__p_long, 
_swigt__p_CApnFilterWheel, 
_swigt__p_unsigned_short, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

SWIGEXPORT(int) Filter_usb_Init(Tcl_Interp *interp) {
    int i;
    if (interp == 0) return TCL_ERROR;
    for (i = 0; swig_types_initial[i]; i++) {
        swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
    }
    for (i = 0; swig_commands[i].name; i++) {
        Tcl_CreateObjCommand(interp, (char *) swig_commands[i].name, swig_commands[i].wrapper, swig_commands[i].clientdata, NULL);
    }
    for (i = 0; swig_variables[i].name; i++) {
        Tcl_SetVar(interp, (char *) swig_variables[i].name, "", TCL_GLOBAL_ONLY);
        Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_READS | TCL_GLOBAL_ONLY, swig_variables[i].get, (ClientData) swig_variables[i].addr);
        Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_WRITES | TCL_GLOBAL_ONLY, swig_variables[i].set, (ClientData) swig_variables[i].addr);
    }
    return TCL_OK;
}

